{
    "version": "https://jsonfeed.org/version/1",
    "title": "",
    "subtitle": "欢迎来到licwuu的博客小站",
    "icon": "http://licwuu.github.io/blog/images/favicon.ico",
    "description": "记录Bug",
    "home_page_url": "http://licwuu.github.io/blog",
    "items": [
        {
            "id": "http://licwuu.github.io/blog/hello-world/",
            "url": "http://licwuu.github.io/blog/hello-world/",
            "title": "Hello World",
            "date_published": "2023-05-11T09:17:49.270Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        },
        {
            "id": "http://licwuu.github.io/blog/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/",
            "url": "http://licwuu.github.io/blog/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/",
            "title": "JSR303数据校验",
            "date_published": "2022-10-18T14:25:43.000Z",
            "content_html": "<h2 id=\"什么是jrs303\"><a class=\"anchor\" href=\"#什么是jrs303\">#</a> 什么是 JRS303</h2>\n<p>JRS303 是一种后端校验技术，是 JAVA EE 6 中的一项子规范，叫做 Bean Validation，Hibernate Validator 是 Bean Validation 的参考实现，通常用于校验数据的合法性，使用非常简单。</p>\n<h2 id=\"如何使用\"><a class=\"anchor\" href=\"#如何使用\">#</a> 如何使用</h2>\n<ol>\n<li>使用校验注解</li>\n</ol>\n<p>在 Java 中提供了一系列的校验方式，它这些校验方式在 “javax.validation.constraints” 包中，包括如下几种注解。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/cover/image-20221018224702539.png\" alt=\"image-20221018224702539\" /></p>\n",
            "tags": [
                "default",
                "default"
            ]
        },
        {
            "id": "http://licwuu.github.io/blog/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/",
            "url": "http://licwuu.github.io/blog/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/",
            "title": "docker安装常用软件",
            "date_published": "2022-10-15T14:01:53.000Z",
            "content_html": "",
            "tags": [
                "default",
                "default"
            ]
        },
        {
            "id": "http://licwuu.github.io/blog/docker%E5%AD%A6%E4%B9%A0/",
            "url": "http://licwuu.github.io/blog/docker%E5%AD%A6%E4%B9%A0/",
            "title": "Docker学习",
            "date_published": "2022-10-15T13:22:31.000Z",
            "content_html": "<h2 id=\"1初识docker\"><a class=\"anchor\" href=\"#1初识docker\">#</a> 1. 初识 Docker</h2>\n<h3 id=\"11什么是docker\"><a class=\"anchor\" href=\"#11什么是docker\">#</a> 1.1. 什么是 Docker</h3>\n<p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>\n<ul>\n<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>\n<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>\n</ul>\n<h4 id=\"111应用部署的环境问题\"><a class=\"anchor\" href=\"#111应用部署的环境问题\">#</a> 1.1.1. 应用部署的环境问题</h4>\n<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>\n<ul>\n<li>\n<p>依赖关系复杂，容易出现兼容性问题</p>\n</li>\n<li>\n<p>开发、测试、生产环境有差异</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731141907366.png\" alt=\"image-20210731141907366\" /></p>\n<p>例如一个项目中，部署时需要依赖于 node.js、Redis、RabbitMQ、MySQL 等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>\n<h4 id=\"112docker解决依赖兼容问题\"><a class=\"anchor\" href=\"#112docker解决依赖兼容问题\">#</a> 1.1.2.Docker 解决依赖兼容问题</h4>\n<p>而 Docker 确巧妙的解决了这些问题，Docker 是如何实现的呢？</p>\n<p>Docker 为了解决依赖的兼容问题的，采用了两个手段：</p>\n<ul>\n<li>\n<p>将应用的 Libs（函数库）、Deps（依赖）、配置与应用一起打包</p>\n</li>\n<li>\n<p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731142219735.png\" alt=\"image-20210731142219735\" /></p>\n<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的 Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>\n<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>\n<h4 id=\"113docker解决操作系统环境差异\"><a class=\"anchor\" href=\"#113docker解决操作系统环境差异\">#</a> 1.1.3.Docker 解决操作系统环境差异</h4>\n<p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个 Ubuntu 操作系统为例，结构如下：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731143401460.png\" alt=\"image-20210731143401460\" /></p>\n<p>结构包括：</p>\n<ul>\n<li>计算机硬件：例如 CPU、内存、磁盘等</li>\n<li>系统内核：所有 Linux 发行版的内核都是 Linux，例如 CentOS、Ubuntu、Fedora 等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>\n<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>\n</ul>\n<p>应用于计算机交互的流程如下：</p>\n<p>1）应用调用操作系统应用（函数库），实现各种功能</p>\n<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>\n<p>3）内核指令操作计算机硬件</p>\n<p>Ubuntu 和 CentOSpringBoot 都是基于 Linux 内核，无非是系统应用不同，提供的函数库有差异：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731144304990.png\" alt=\"image-20210731144304990\" /></p>\n<p>此时，如果将一个 Ubuntu 版本的 MySQL 应用安装到 CentOS 系统，MySQL 在调用 Ubuntu 函数库时，会发现找不到或者不匹配，就会报错了：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731144458680.png\" alt=\"image-20210731144458680\" /></p>\n<p>Docker 如何解决不同系统环境的问题？</p>\n<ul>\n<li>Docker 将用户程序与所需要调用的系统 (比如 Ubuntu) 函数库一起打包</li>\n<li>Docker 运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的 Linux 内核来运行</li>\n</ul>\n<p>如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731144820638.png\" alt=\"image-20210731144820638\" /></p>\n<h4 id=\"114小结\"><a class=\"anchor\" href=\"#114小结\">#</a> 1.1.4. 小结</h4>\n<p>Docker 如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>\n<ul>\n<li>Docker 允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>\n<li>Docker 应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>\n</ul>\n<p>Docker 如何解决开发、测试、生产环境有差异的问题？</p>\n<ul>\n<li>Docker 镜像中包含完整运行环境，包括系统函数库，仅依赖系统的 Linux 内核，因此可以在任意 Linux 操作系统上运行</li>\n</ul>\n<p>Docker 是一个快速交付应用、运行应用的技术，具备下列优势：</p>\n<ul>\n<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统</li>\n<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>\n<li>启动、移除都可以通过一行命令完成，方便快捷</li>\n</ul>\n<h3 id=\"12docker和虚拟机的区别\"><a class=\"anchor\" href=\"#12docker和虚拟机的区别\">#</a> 1.2.Docker 和虚拟机的区别</h3>\n<p>Docker 可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>\n<p>两者有什么差异呢？</p>\n<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的 Ubuntu 应用了。</p>\n<p><strong>Docker</strong> 仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731145914960.png\" alt=\"image-20210731145914960\" /></p>\n<p>对比来看：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731152243765.png\" alt=\"image-20210731152243765\" /></p>\n<p>小结：</p>\n<p>Docker 和虚拟机的差异：</p>\n<ul>\n<li>\n<p>docker 是一个系统进程；虚拟机是在操作系统中的操作系统</p>\n</li>\n<li>\n<p>docker 体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>\n</li>\n</ul>\n<h3 id=\"13docker架构\"><a class=\"anchor\" href=\"#13docker架构\">#</a> 1.3.Docker 架构</h3>\n<h4 id=\"131镜像和容器\"><a class=\"anchor\" href=\"#131镜像和容器\">#</a> 1.3.1. 镜像和容器</h4>\n<p>Docker 中有几个重要的概念：</p>\n<p><strong>镜像（Image）</strong>：Docker 将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>\n<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是 Docker 会给容器进程做隔离，对外不可见。</p>\n<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>\n<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>\n<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731153059464.png\" alt=\"image-20210731153059464\" /></p>\n<p>例如你下载了一个 QQ，如果我们将 QQ 在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成 QQ 镜像。然后你可以启动多次，双开、甚至三开 QQ，跟多个妹子聊天。</p>\n<h4 id=\"132dockerhub\"><a class=\"anchor\" href=\"#132dockerhub\">#</a> 1.3.2.DockerHub</h4>\n<p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如 Redis、MySQL 镜像放到网络上，共享使用，就像 GitHub 的代码共享一样。</p>\n<ul>\n<li>\n<p>DockerHub：DockerHub 是一个官方的 Docker 镜像的托管平台。这样的平台称为 Docker Registry。</p>\n</li>\n<li>\n<p>国内也有类似于 DockerHub 的公开服务，比如 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jLjE2M3l1bi5jb20vaHVi\">网易云镜像服务</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20v\">阿里云镜像库</span>等。</p>\n</li>\n</ul>\n<p>我们一方面可以将自己的镜像共享到 DockerHub，另一方面也可以从 DockerHub 拉取镜像：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731153743354.png\" alt=\"image-20210731153743354\" /></p>\n<h4 id=\"133docker架构\"><a class=\"anchor\" href=\"#133docker架构\">#</a> 1.3.3.Docker 架构</h4>\n<p>我们要使用 Docker 来操作镜像、容器，就必须要安装 Docker。</p>\n<p>Docker 是一个 CS 架构的程序，由两部分组成：</p>\n<ul>\n<li>\n<p>服务端 (server)：Docker 守护进程，负责处理 Docker 指令，管理镜像、容器等</p>\n</li>\n<li>\n<p>客户端 (client)：通过命令或 RestAPI 向 Docker 服务端发送指令。可以在本地或远程向服务端发送指令。</p>\n</li>\n</ul>\n<p>如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731154257653.png\" alt=\"image-20210731154257653\" /></p>\n<h4 id=\"134小结\"><a class=\"anchor\" href=\"#134小结\">#</a> 1.3.4. 小结</h4>\n<p>镜像：</p>\n<ul>\n<li>将应用程序及其依赖、环境、配置打包在一起</li>\n</ul>\n<p>容器：</p>\n<ul>\n<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>\n</ul>\n<p>Docker 结构：</p>\n<ul>\n<li>\n<p>服务端：接收命令或远程请求，操作镜像或容器</p>\n</li>\n<li>\n<p>客户端：发送命令或者请求到 Docker 服务端</p>\n</li>\n</ul>\n<p>DockerHub：</p>\n<ul>\n<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为 DockerRegistry</li>\n</ul>\n<h3 id=\"14安装docker\"><a class=\"anchor\" href=\"#14安装docker\">#</a> 1.4. 安装 Docker</h3>\n<p>企业部署一般都是采用 Linux 操作系统，而其中又数 CentOS 发行版占比最多，因此我们在 CentOS 下安装 Docker。参考课前资料中的文档：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731155002425.png\" alt=\"image-20210731155002425\" /></p>\n<h2 id=\"2docker的基本操作\"><a class=\"anchor\" href=\"#2docker的基本操作\">#</a> 2.Docker 的基本操作</h2>\n<h3 id=\"21镜像操作\"><a class=\"anchor\" href=\"#21镜像操作\">#</a> 2.1. 镜像操作</h3>\n<h4 id=\"211镜像名称\"><a class=\"anchor\" href=\"#211镜像名称\">#</a> 2.1.1. 镜像名称</h4>\n<p>首先来看下镜像的名称组成：</p>\n<ul>\n<li>镜名称一般分两部分组成：[repository]:[tag]。</li>\n<li>在没有指定 tag 时，默认是 latest，代表最新版本的镜像</li>\n</ul>\n<p>如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731155141362.png\" alt=\"image-20210731155141362\" /></p>\n<p>这里的 mysql 就是 repository，5.7 就是 tag，合一起就是镜像名称，代表 5.7 版本的 MySQL 镜像。</p>\n<h4 id=\"212镜像命令\"><a class=\"anchor\" href=\"#212镜像命令\">#</a> 2.1.2. 镜像命令</h4>\n<p>常见的镜像操作命令如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731155649535.png\" alt=\"image-20210731155649535\" /></p>\n<h4 id=\"213案例1-拉取-查看镜像\"><a class=\"anchor\" href=\"#213案例1-拉取-查看镜像\">#</a> 2.1.3. 案例 1 - 拉取、查看镜像</h4>\n<p>需求：从 DockerHub 中拉取一个 nginx 镜像并查看</p>\n<p>1）首先去镜像仓库搜索 nginx 镜像，比如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=\"> DockerHub</span>:</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731155844368.png\" alt=\"image-20210731155844368\" /></p>\n<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731155856199.png\" alt=\"image-20210731155856199\" /></p>\n<p>3）通过命令：docker images 查看拉取到的镜像</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731155903037.png\" alt=\"image-20210731155903037\" /></p>\n<h4 id=\"214案例2-保存-导入镜像\"><a class=\"anchor\" href=\"#214案例2-保存-导入镜像\">#</a> 2.1.4. 案例 2 - 保存、导入镜像</h4>\n<p>需求：利用 docker save 将 nginx 镜像导出磁盘，然后再通过 load 加载回来</p>\n<p>1）利用 docker xx --help 命令查看 docker save 和 docker load 的语法</p>\n<p>例如，查看 save 命令用法，可以输入命令：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> save <span class=\"token parameter variable\">--help</span></pre></td></tr></table></figure><p>结果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731161104732.png\" alt=\"image-20210731161104732\" /></p>\n<p>命令格式：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> save <span class=\"token parameter variable\">-o</span> <span class=\"token punctuation\">[</span>保存的目标文件名称<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>镜像名称<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>2）使用 docker save 导出镜像到磁盘</p>\n<p>运行命令：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> save <span class=\"token parameter variable\">-o</span> nginx.tar nginx:latest</pre></td></tr></table></figure><p>结果如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731161354344.png\" alt=\"image-20210731161354344\" /></p>\n<p>3）使用 docker load 加载镜像</p>\n<p>先删除本地的 nginx 镜像：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> rmi nginx:latest</pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> load <span class=\"token parameter variable\">-i</span> nginx.tar</pre></td></tr></table></figure><p>结果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731161746245.png\" alt=\"image-20210731161746245\" /></p>\n<h4 id=\"215练习\"><a class=\"anchor\" href=\"#215练习\">#</a> 2.1.5. 练习</h4>\n<p>需求：去 DockerHub 搜索并拉取一个 Redis 镜像</p>\n<p>目标：</p>\n<p>1）去 DockerHub 搜索 Redis 镜像</p>\n<p>2）查看 Redis 镜像的名称和版本</p>\n<p>3）利用 docker pull 命令拉取镜像</p>\n<p>4）利用 docker save 命令将 redis:latest 打包为一个 redis.tar 包</p>\n<p>5）利用 docker rmi 删除本地的 redis:latest</p>\n<p>6）利用 docker load 重新加载 redis.tar 文件</p>\n<h3 id=\"22容器操作\"><a class=\"anchor\" href=\"#22容器操作\">#</a> 2.2. 容器操作</h3>\n<h4 id=\"221容器相关命令\"><a class=\"anchor\" href=\"#221容器相关命令\">#</a> 2.2.1. 容器相关命令</h4>\n<p>容器操作的命令如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731161950495.png\" alt=\"image-20210731161950495\" /></p>\n<p>容器保护三个状态：</p>\n<ul>\n<li>运行：进程正常运行</li>\n<li>暂停：进程暂停，CPU 不再运行，并不释放内存</li>\n<li>停止：进程终止，回收进程占用的内存、CPU 等资源</li>\n</ul>\n<p>其中：</p>\n<ul>\n<li>\n<p>docker run：创建并运行一个容器，处于运行状态</p>\n</li>\n<li>\n<p>docker pause：让一个运行的容器暂停</p>\n</li>\n<li>\n<p>docker unpause：让一个容器从暂停状态恢复运行</p>\n</li>\n<li>\n<p>docker stop：停止一个运行的容器</p>\n</li>\n<li>\n<p>docker start：让一个停止的容器再次运行</p>\n</li>\n<li>\n<p>docker rm：删除一个容器</p>\n</li>\n</ul>\n<h4 id=\"222案例-创建并运行一个容器\"><a class=\"anchor\" href=\"#222案例-创建并运行一个容器\">#</a> 2.2.2. 案例 - 创建并运行一个容器</h4>\n<p>创建并运行 nginx 容器的命令：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> containerName <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 <span class=\"token parameter variable\">-d</span> nginx</pre></td></tr></table></figure><p>命令解读：</p>\n<ul>\n<li>docker run ：创建并运行一个容器</li>\n<li>--name : 给容器起一个名字，比如叫做 mn</li>\n<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>\n<li>-d：后台运行容器</li>\n<li>nginx：镜像名称，例如 nginx</li>\n</ul>\n<p>这里的 <code>-p</code>  参数，是将容器端口映射到宿主机端口。</p>\n<p>默认情况下，容器是隔离环境，我们直接访问宿主机的 80 端口，肯定访问不到容器中的 nginx。</p>\n<p>现在，将容器的 80 与宿主机的 80 关联起来，当我们访问宿主机的 80 端口时，就会被映射到容器的 80，这样就能访问到 nginx 了：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731163255863.png\" alt=\"image-20210731163255863\" /></p>\n<h4 id=\"223案例-进入容器修改文件\"><a class=\"anchor\" href=\"#223案例-进入容器修改文件\">#</a> 2.2.3. 案例 - 进入容器，修改文件</h4>\n<p><strong>需求</strong>：进入 Nginx 容器，修改 HTML 文件内容，添加 “传智教育欢迎您”</p>\n<p><strong>提示</strong>：进入容器要用到 docker exec 命令。</p>\n<p><strong>步骤</strong>：</p>\n<p>1）进入容器。进入我们刚刚创建的 nginx 容器的命令为：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> mn <span class=\"token function\">bash</span></pre></td></tr></table></figure><p>命令解读：</p>\n<ul>\n<li>\n<p>docker exec ：进入容器内部，执行一个命令</p>\n</li>\n<li>\n<p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>\n</li>\n<li>\n<p>mn ：要进入的容器的名称</p>\n</li>\n<li>\n<p>bash：进入容器后执行的命令，bash 是一个 linux 终端交互命令</p>\n</li>\n</ul>\n<p>2）进入 nginx 的 HTML 所在目录 /usr/share/nginx/html</p>\n<p>容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 linux 服务器一样：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731164159811.png\" alt=\"image-20210731164159811\" /></p>\n<p>nginx 的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的 html 文件。</p>\n<p>查看 DockerHub 网站中的 nginx 页面，可以知道 nginx 的 html 目录位置在 <code>/usr/share/nginx/html</code></p>\n<p>我们执行命令，进入该目录：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /usr/share/nginx/html</pre></td></tr></table></figure><p>查看目录下文件：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731164455818.png\" alt=\"image-20210731164455818\" /></p>\n<p>3）修改 index.html 的内容</p>\n<p>容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-i</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">'s#Welcome to nginx#传智教育欢迎您#g'</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">'s#&lt;head>#&lt;head>&lt;meta charset=\"utf-8\">#g'</span> index.html</pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<span class=\"exturl\" data-url=\"aHR0cDovLzE5Mi4xNjguMTUwLjEwMQ==\">http://192.168.150.101</span>，即可看到结果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731164717604.png\" alt=\"image-20210731164717604\" /></p>\n<h4 id=\"224小结\"><a class=\"anchor\" href=\"#224小结\">#</a> 2.2.4. 小结</h4>\n<p>docker run 命令的常见参数有哪些？</p>\n<ul>\n<li>--name：指定容器名称</li>\n<li>-p：指定端口映射</li>\n<li>-d：让容器后台运行</li>\n</ul>\n<p>查看容器日志的命令：</p>\n<ul>\n<li>docker logs</li>\n<li>添加 -f 参数可以持续查看日志</li>\n</ul>\n<p>查看容器状态：</p>\n<ul>\n<li>docker ps</li>\n<li>docker ps -a 查看所有容器，包括已经停止的</li>\n</ul>\n<h3 id=\"23数据卷容器数据管理\"><a class=\"anchor\" href=\"#23数据卷容器数据管理\">#</a> 2.3. 数据卷（容器数据管理）</h3>\n<p>在之前的 nginx 案例中，修改 nginx 的 html 页面时，需要进入 nginx 内部。并且因为没有编辑器，修改文件也很麻烦。</p>\n<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731172440275.png\" alt=\"image-20210731172440275\" /></p>\n<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>\n<h4 id=\"231什么是数据卷\"><a class=\"anchor\" href=\"#231什么是数据卷\">#</a> 2.3.1. 什么是数据卷</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731173541846.png\" alt=\"image-20210731173541846\" /></p>\n<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>\n<p>这样，我们操作宿主机的 /var/lib/docker/volumes/html 目录，就等于操作容器内的 /usr/share/nginx/html 目录了</p>\n<h4 id=\"232数据集操作命令\"><a class=\"anchor\" href=\"#232数据集操作命令\">#</a> 2.3.2. 数据集操作命令</h4>\n<p>数据卷操作的基本语法如下：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> volume <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>docker volume 命令是数据卷操作，根据命令后跟随的 command 来确定下一步的操作：</p>\n<ul>\n<li>create 创建一个 volume</li>\n<li>inspect 显示一个或多个 volume 的信息</li>\n<li>ls 列出所有的 volume</li>\n<li>prune 删除未使用的 volume</li>\n<li>rm 删除一个或多个指定的 volume</li>\n</ul>\n<h4 id=\"233创建和查看数据卷\"><a class=\"anchor\" href=\"#233创建和查看数据卷\">#</a> 2.3.3. 创建和查看数据卷</h4>\n<p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>\n<p>① 创建数据卷</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> volume create html</pre></td></tr></table></figure><p>② 查看所有数据</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> volume <span class=\"token function\">ls</span></pre></td></tr></table></figure><p>结果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731173746910.png\" alt=\"image-20210731173746910\" /></p>\n<p>③ 查看数据卷详细信息卷</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> volume inspect html</pre></td></tr></table></figure><p>结果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731173809877.png\" alt=\"image-20210731173809877\" /></p>\n<p>可以看到，我们创建的 html 这个数据卷关联的宿主机目录为 <code>/var/lib/docker/volumes/html/_data</code>  目录。</p>\n<p><strong>小结</strong>：</p>\n<p>数据卷的作用：</p>\n<ul>\n<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>\n</ul>\n<p>数据卷操作：</p>\n<ul>\n<li>docker volume create：创建数据卷</li>\n<li>docker volume ls：查看所有数据卷</li>\n<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>\n<li>docker volume rm：删除指定数据卷</li>\n<li>docker volume prune：删除所有未使用的数据卷</li>\n</ul>\n<h4 id=\"234挂载数据卷\"><a class=\"anchor\" href=\"#234挂载数据卷\">#</a> 2.3.4. 挂载数据卷</h4>\n<p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token parameter variable\">--name</span> mn <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token parameter variable\">-v</span> html:/root/html <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:80</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  nginx <span class=\"token punctuation\">\\</span></pre></td></tr></table></figure><p>这里的 - v 就是挂载数据卷的命令：</p>\n<ul>\n<li><code>-v html:/root/htm</code>  ：把 html 数据卷挂载到容器内的 /root/html 这个目录中</li>\n</ul>\n<h4 id=\"235案例-给nginx挂载数据卷\"><a class=\"anchor\" href=\"#235案例-给nginx挂载数据卷\">#</a> 2.3.5. 案例 - 给 nginx 挂载数据卷</h4>\n<p><strong>需求</strong>：创建一个 nginx 容器，修改容器内的 html 目录内的 index.html 内容</p>\n<p><strong>分析</strong>：上个案例中，我们进入 nginx 容器内部，已经知道 nginx 的 html 目录所在位置 /usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容。</p>\n<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>\n<p>步骤：</p>\n<p>① 创建容器并挂载数据卷到容器内的 HTML 目录</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> mn <span class=\"token parameter variable\">-v</span> html:/usr/share/nginx/html <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 <span class=\"token parameter variable\">-d</span> nginx</pre></td></tr></table></figure><p>② 进入 html 数据卷所在位置，并修改 HTML 内容</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">## 查看 html 数据卷的位置</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> volume inspect html</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">## 进入该目录</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /var/lib/docker/volumes/html/_data</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">## 修改文件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">vi</span> index.html</pre></td></tr></table></figure><h4 id=\"236案例-给mysql挂载本地目录\"><a class=\"anchor\" href=\"#236案例-给mysql挂载本地目录\">#</a> 2.3.6. 案例 - 给 MySQL 挂载本地目录</h4>\n<p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>\n<ul>\n<li>带数据卷模式：宿主机目录 --&gt; 数据卷 ---&gt; 容器内目录</li>\n<li>直接挂载模式：宿主机目录 ---&gt; 容器内目录</li>\n</ul>\n<p>如图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731175155453.png\" alt=\"image-20210731175155453\" /></p>\n<p><strong>语法</strong>：</p>\n<p>目录挂载与数据卷挂载的语法是类似的：</p>\n<ul>\n<li>-v [宿主机目录]:[容器内目录]</li>\n<li>-v [宿主机文件]:[容器内文件]</li>\n</ul>\n<p><strong>需求</strong>：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器</p>\n<p>实现思路如下：</p>\n<p>1）在将课前资料中的 mysql.tar 文件上传到虚拟机，通过 load 命令加载为镜像</p>\n<p>2）创建目录 /tmp/mysql/data</p>\n<p>3）创建目录 /tmp/mysql/conf，将课前资料提供的 hmy.cnf 文件上传到 /tmp/mysql/conf</p>\n<p>4）去 DockerHub 查阅资料，创建并运行 MySQL 容器，要求：</p>\n<p>① 挂载 /tmp/mysql/data 到 mysql 容器内数据存储目录</p>\n<p>② 挂载 /tmp/mysql/conf/hmy.cnf 到 mysql 容器的配置文件</p>\n<p>③ 设置 MySQL 密码</p>\n<p><strong>命令：</strong></p>\n<figure class=\"highlight docker\"><figcaption data-lang=\"docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run \\</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>--name contain-mysql \\</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-e MYSQL_ROOT_PASSWORD=123456 \\</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-p 3306:3306 \\</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-v /tmp/mysql/conf/hmy.conf:/etc/mysql/conf.d/hmy.conf \\</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>-v /tmp/mysql/data:/var/lib/mysql \\</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>-d \\</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>mysql:5.7.25</pre></td></tr></table></figure><h4 id=\"237小结\"><a class=\"anchor\" href=\"#237小结\">#</a> 2.3.7. 小结</h4>\n<p>docker run 的命令中通过 -v 参数挂载文件或目录到容器中：</p>\n<ul>\n<li>-v volume 名称：容器内目录</li>\n<li>-v 宿主机文件：容器内文</li>\n<li>-v 宿主机目录：容器内目录</li>\n</ul>\n<p>数据卷挂载与目录直接挂载的</p>\n<ul>\n<li>数据卷挂载耦合度低，由 docker 来管理目录，但是目录较深，不好找</li>\n<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>\n</ul>\n<h2 id=\"3dockerfile自定义镜像\"><a class=\"anchor\" href=\"#3dockerfile自定义镜像\">#</a> 3.Dockerfile 自定义镜像</h2>\n<p>常见的镜像在 DockerHub 就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>\n<p>而要自定义镜像，就必须先了解镜像的结构才行。</p>\n<h3 id=\"31镜像结构\"><a class=\"anchor\" href=\"#31镜像结构\">#</a> 3.1. 镜像结构</h3>\n<p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>\n<p>我们以 MySQL 为例，来看看镜像的组成结构：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731175806273.png\" alt=\"image-20210731175806273\" /></p>\n<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>\n<p>我们要构建镜像，其实就是实现上述打包的过程。</p>\n<h3 id=\"32dockerfile语法\"><a class=\"anchor\" href=\"#32dockerfile语法\">#</a> 3.2.Dockerfile 语法</h3>\n<p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>\n<p>我们只需要告诉 Docker，我们的镜像的组成，需要哪些 BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来 Docker 会帮助我们构建镜像。</p>\n<p>而描述上述信息的文件就是 Dockerfile 文件。</p>\n<p><strong>Dockerfile</strong> 就是一个文本文件，其中包含一个个的<strong>指令 (Instruction)</strong>，用指令来说明</p>\n<p>要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731180321133.png\" alt=\"image-20210731180321133\" /></p>\n<p>更新详细语法说明，请参考官网文档： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVy\">https://docs.docker.com/engine/reference/builder</span></p>\n<h3 id=\"33构建java项目\"><a class=\"anchor\" href=\"#33构建java项目\">#</a> 3.3. 构建 Java 项目</h3>\n<h4 id=\"331基于ubuntu构建java项目\"><a class=\"anchor\" href=\"#331基于ubuntu构建java项目\">#</a> 3.3.1. 基于 Ubuntu 构建 Java 项目</h4>\n<p>需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 java 项目</p>\n<ul>\n<li>\n<p>步骤 1：新建一个空文件夹 docker-demo</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801101207444.png\" alt=\"image-20210801101207444\" /></p>\n</li>\n<li>\n<p>步骤 2：拷贝课前资料中的 docker-demo.jar 文件到 docker-demo 这个目录</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801101314816.png\" alt=\"image-20210801101314816\" /></p>\n</li>\n<li>\n<p>步骤 3：拷贝课前资料中的 jdk8.tar.gz 文件到 docker-demo 这个目录</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801101410200.png\" alt=\"image-20210801101410200\" /></p>\n</li>\n<li>\n<p>步骤 4：拷贝课前资料提供的 Dockerfile 到 docker-demo 这个目录</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801101455590.png\" alt=\"image-20210801101455590\" /></p>\n<p>其中的内容如下：</p>\n<figure class=\"highlight dockerfile\"><figcaption data-lang=\"Docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">## 指定基础镜像</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu:16.04</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">## 配置环境变量，JDK 的安装目录</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> JAVA_DIR=/usr/local</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">## 拷贝 jdk 和 java 项目的包</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./jdk8.tar.gz <span class=\"token variable\">$JAVA_DIR</span>/</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./docker-demo.jar /tmp/app.jar</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">## 安装 JDK</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> cd <span class=\"token variable\">$JAVA_DIR</span> <span class=\"token operator\">\\</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre> &amp;&amp; tar -xf ./jdk8.tar.gz <span class=\"token operator\">\\</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">## 配置环境变量</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> JAVA_HOME=<span class=\"token variable\">$JAVA_DIR</span>/java8</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> PATH=<span class=\"token variable\">$PATH</span>:<span class=\"token variable\">$JAVA_HOME</span>/bin</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">## 暴露端口</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 8090</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">## 入口，java 项目的启动命令</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> java -jar /tmp/app.jar</span></pre></td></tr></table></figure></li>\n<li>\n<p>步骤 5：进入 docker-demo</p>\n<p>将准备好的 docker-demo 上传到虚拟机任意目录，然后进入 docker-demo 目录下</p>\n</li>\n<li>\n<p>步骤 6：运行命令：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> javaweb:1.0 <span class=\"token builtin class-name\">.</span></pre></td></tr></table></figure></li>\n</ul>\n<p>最后访问 <span class=\"exturl\" data-url=\"aHR0cDovLzE5Mi4xNjguMTUwLjEwMTo4MDkwL2hlbGxvL2NvdW50JUVGJUJDJThDJUU1JTg1JUI2JUU0JUI4JUFEJUU3JTlBJTg0aXAlRTYlOTQlQjklRTYlODglOTAlRTQlQkQlQTAlRTclOUElODQlRTglOTklOUElRTYlOEIlOUYlRTYlOUMlQkFpcA==\">http://192.168.150.101:8090/hello/count，其中的 ip 改成你的虚拟机 ip</span></p>\n<h4 id=\"332基于java8构建java项目\"><a class=\"anchor\" href=\"#332基于java8构建java项目\">#</a> 3.3.2. 基于 java8 构建 Java 项目</h4>\n<p>虽然我们可以基于 Ubuntu 基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>\n<p>例如，构建 java 项目的镜像，可以在已经准备了 JDK 的基础镜像基础上构建。</p>\n<p>需求：基于 java:8-alpine 镜像，将一个 Java 项目构建为镜像</p>\n<p>实现思路如下：</p>\n<ul>\n<li>\n<p>① 新建一个空的目录，然后在目录中新建一个文件，命名为 Dockerfile</p>\n</li>\n<li>\n<p>② 拷贝课前资料提供的 docker-demo.jar 到这个目录中</p>\n</li>\n<li>\n<p>③ 编写 Dockerfile 文件：</p>\n<ul>\n<li>\n<p>a ）基于 java:8-alpine 作为基础镜像</p>\n</li>\n<li>\n<p>b ）将 app.jar 拷贝到镜像中</p>\n</li>\n<li>\n<p>c ）暴露端口</p>\n</li>\n<li>\n<p>d ）编写入口 ENTRYPOINT</p>\n<p>内容如下：</p>\n<figure class=\"highlight dockerfile\"><figcaption data-lang=\"Docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> java:8-alpine</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./app.jar /tmp/app.jar</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 8090</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> java -jar /tmp/app.jar</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>④ 使用 docker build 命令构建镜像</p>\n</li>\n<li>\n<p>⑤ 使用 docker run 创建容器并运行</p>\n</li>\n</ul>\n<h3 id=\"34小结\"><a class=\"anchor\" href=\"#34小结\">#</a> 3.4. 小结</h3>\n<p>小结：</p>\n<ol>\n<li>\n<p>Dockerfile 的本质是一个文件，通过指令描述镜像的构建过程</p>\n</li>\n<li>\n<p>Dockerfile 的第一行必须是 FROM，从一个基础镜像来构建</p>\n</li>\n<li>\n<p>基础镜像可以是基本操作系统，如 Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p>\n</li>\n</ol>\n<h2 id=\"4docker-compose\"><a class=\"anchor\" href=\"#4docker-compose\">#</a> 4.Docker-Compose</h2>\n<p>Docker Compose 可以基于 Compose 文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731180921742.png\" alt=\"image-20210731180921742\" /></p>\n<h3 id=\"41初识dockercompose\"><a class=\"anchor\" href=\"#41初识dockercompose\">#</a> 4.1. 初识 DockerCompose</h3>\n<p>Compose 文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>version<span class=\"token operator\">:</span> <span class=\"token string\">\"3.8\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> services<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  mysql<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    image<span class=\"token operator\">:</span> mysql<span class=\"token operator\">:</span><span class=\"token number\">5.7</span>.<span class=\"token number\">25</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    environment<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     MYSQL_ROOT_PASSWORD<span class=\"token operator\">:</span> <span class=\"token number\">123</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    volumes<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     - <span class=\"token string\">\"/tmp/mysql/data:/var/lib/mysql\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     - <span class=\"token string\">\"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf\"</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  web<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    build<span class=\"token operator\">:</span> .</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    ports<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>     - <span class=\"token string\">\"8090:8090\"</span></pre></td></tr></table></figure><p>上面的 Compose 文件就描述一个项目，其中包含两个容器：</p>\n<ul>\n<li>mysql：一个基于 <code>mysql:5.7.25</code>  镜像构建的容器，并且挂载了两个目录</li>\n<li>web：一个基于 <code>docker build</code>  临时构建的镜像容器，映射端口时 8090</li>\n</ul>\n<p>DockerCompose 的详细语法参考官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9jb21wb3NlLWZpbGUv\">https://docs.docker.com/compose/compose-file/</span></p>\n<p>其实 DockerCompose 文件可以看做是将多个 docker run 命令写到一个文件，只是语法稍有差异。</p>\n<h3 id=\"42安装dockercompose\"><a class=\"anchor\" href=\"#42安装dockercompose\">#</a> 4.2. 安装 DockerCompose</h3>\n<p>参考课前资料</p>\n<h3 id=\"43部署微服务集群\"><a class=\"anchor\" href=\"#43部署微服务集群\">#</a> 4.3. 部署微服务集群</h3>\n<p><strong>需求</strong>：将之前学习的 cloud-demo 微服务集群利用 DockerCompose 部署</p>\n<p><strong>实现思路</strong>：</p>\n<p>① 查看课前资料提供的 cloud-demo 文件夹，里面已经编写好了 docker-compose 文件</p>\n<p>② 修改自己的 cloud-demo 项目，将数据库、nacos 地址都命名为 docker-compose 中的服务名</p>\n<p>③ 使用 maven 打包工具，将项目中的每个微服务都打包为 app.jar</p>\n<p>④ 将打包好的 app.jar 拷贝到 cloud-demo 中的每一个对应的子目录中</p>\n<p>⑤ 将 cloud-demo 上传至虚拟机，利用 docker-compose up -d 来部署</p>\n<h4 id=\"431compose文件\"><a class=\"anchor\" href=\"#431compose文件\">#</a> 4.3.1.compose 文件</h4>\n<p>查看课前资料提供的 cloud-demo 文件夹，里面已经编写好了 docker-compose 文件，而且每个微服务都准备了一个独立的目录：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210731181341330.png\" alt=\"image-20210731181341330\" /></p>\n<p>内容如下：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3.2\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nacos/nacos<span class=\"token punctuation\">-</span>server</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      <span class=\"token key atrule\">MODE</span><span class=\"token punctuation\">:</span> standalone</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"8848:8848\"</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token key atrule\">mysql</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mysql<span class=\"token punctuation\">:</span>5.7.25</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token key atrule\">MYSQL_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> <span class=\"token number\">123</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"$PWD/mysql/data:/var/lib/mysql\"</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"$PWD/mysql/conf:/etc/mysql/conf.d/\"</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token key atrule\">userservice</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> ./user<span class=\"token punctuation\">-</span>service</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token key atrule\">orderservice</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> ./order<span class=\"token punctuation\">-</span>service</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token key atrule\">gateway</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> ./gateway</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"10010:10010\"</span></pre></td></tr></table></figure><p>可以看到，其中包含 5 个 service 服务：</p>\n<ul>\n<li><code>nacos</code> ：作为注册中心和配置中心\n<ul>\n<li><code>image: nacos/nacos-server</code> ： 基于 nacos/nacos-server 镜像构建</li>\n<li><code>environment</code> ：环境变量\n<ul>\n<li><code>MODE: standalone</code> ：单点模式启动</li>\n</ul>\n</li>\n<li><code>ports</code> ：端口映射，这里暴露了 8848 端口</li>\n</ul>\n</li>\n<li><code>mysql</code> ：数据库\n<ul>\n<li><code>image: mysql:5.7.25</code> ：镜像版本是 mysql:5.7.25</li>\n<li><code>environment</code> ：环境变量\n<ul>\n<li><code>MYSQL_ROOT_PASSWORD: 123</code> ：设置数据库 root 账户的密码为 123</li>\n</ul>\n</li>\n<li><code>volumes</code> ：数据卷挂载，这里挂载了 mysql 的 data、conf 目录，其中有我提前准备好的数据</li>\n</ul>\n</li>\n<li><code>userservice</code> 、 <code>orderservice</code> 、 <code>gateway</code> ：都是基于 Dockerfile 临时构建的</li>\n</ul>\n<p>查看 mysql 目录，可以看到其中已经准备好了 cloud_order、cloud_user 表：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801095205034.png\" alt=\"image-20210801095205034\" /></p>\n<p>查看微服务目录，可以看到都包含 Dockerfile 文件：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801095320586.png\" alt=\"image-20210801095320586\" /></p>\n<p>内容如下：</p>\n<figure class=\"highlight dockerfile\"><figcaption data-lang=\"Docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> java:8-alpine</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./app.jar /tmp/app.jar</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> java -jar /tmp/app.jar</span></pre></td></tr></table></figure><h4 id=\"432修改微服务配置\"><a class=\"anchor\" href=\"#432修改微服务配置\">#</a> 4.3.2. 修改微服务配置</h4>\n<p>因为微服务将来要部署为 docker 容器，而容器之间互联不是通过 IP 地址，而是通过容器名。这里我们将 order-service、user-service、gateway 服务的 mysql、nacos 地址都修改为基于容器名的访问。</p>\n<p>如下所示：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">datasource</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> jdbc<span class=\"token punctuation\">:</span>mysql<span class=\"token punctuation\">:</span>//mysql<span class=\"token punctuation\">:</span>3306/cloud_order<span class=\"token punctuation\">?</span>useSSL=false</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> root</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> <span class=\"token number\">123</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">driver-class-name</span><span class=\"token punctuation\">:</span> com.mysql.jdbc.Driver</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> orderservice</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> nacos<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span> <span class=\"token comment\">## nacos 服务地址</span></pre></td></tr></table></figure><h4 id=\"433打包\"><a class=\"anchor\" href=\"#433打包\">#</a> 4.3.3. 打包</h4>\n<p>接下来需要将我们的每个微服务都打包。因为之前查看到 Dockerfile 中的 jar 包名称都是 app.jar，因此我们的每个微服务都需要用这个名称。</p>\n<p>可以通过修改 pom.xml 中的打包名称来实现，每个微服务都需要修改：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>build</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">&lt;!-- 服务打包的最终名称 --></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>finalName</span><span class=\"token punctuation\">></span></span>app<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>finalName</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-maven-plugin<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugin</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugins</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>build</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>打包后：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801095951030.png\" alt=\"image-20210801095951030\" /></p>\n<h4 id=\"434拷贝jar包到部署目录\"><a class=\"anchor\" href=\"#434拷贝jar包到部署目录\">#</a> 4.3.4. 拷贝 jar 包到部署目录</h4>\n<p>编译打包好的 app.jar 文件，需要放到 Dockerfile 的同级目录中。注意：每个微服务的 app.jar 放到与服务名称对应的目录，别搞错了。</p>\n<p>user-service：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801100201253.png\" alt=\"image-20210801100201253\" /></p>\n<p>order-service：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801100231495.png\" alt=\"image-20210801100231495\" /></p>\n<p>gateway：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801100308102.png\" alt=\"image-20210801100308102\" /></p>\n<h4 id=\"435部署\"><a class=\"anchor\" href=\"#435部署\">#</a> 4.3.5. 部署</h4>\n<p>最后，我们需要将文件整个 cloud-demo 文件夹上传到虚拟机中，理由 DockerCompose 部署。</p>\n<p>上传到任意目录：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/docker/image-20210801100955653.png\" alt=\"image-20210801100955653\" /></p>\n<p>部署：</p>\n<p>进入 cloud-demo 目录，然后运行下面的命令：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></pre></td></tr></table></figure><h2 id=\"5docker镜像仓库\"><a class=\"anchor\" href=\"#5docker镜像仓库\">#</a> 5.Docker 镜像仓库</h2>\n<h3 id=\"51搭建私有镜像仓库\"><a class=\"anchor\" href=\"#51搭建私有镜像仓库\">#</a> 5.1. 搭建私有镜像仓库</h3>\n<p>参考课前资料《<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1DZW50T1M3RG9ja2VyLWhtMHk0NjcwYy5tZA==\">CentOS7 安装 Docker.md</span>》</p>\n<h3 id=\"52推送-拉取镜像\"><a class=\"anchor\" href=\"#52推送-拉取镜像\">#</a> 5.2. 推送、拉取镜像</h3>\n<p>推送镜像到私有镜像服务必须先 tag，步骤如下：</p>\n<p>① 重新 tag 本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> tag nginx:latest <span class=\"token number\">192.168</span>.150.101:8080/nginx:1.0</pre></td></tr></table></figure><p>② 推送镜像</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> push <span class=\"token number\">192.168</span>.150.101:8080/nginx:1.0</pre></td></tr></table></figure><p>③ 拉取镜像</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull <span class=\"token number\">192.168</span>.150.101:8080/nginx:1.0</pre></td></tr></table></figure>",
            "tags": [
                "学习笔记",
                "docker"
            ]
        },
        {
            "id": "http://licwuu.github.io/blog/docker%E5%AE%89%E8%A3%85/",
            "url": "http://licwuu.github.io/blog/docker%E5%AE%89%E8%A3%85/",
            "title": "docker安装",
            "date_published": "2022-10-15T12:40:02.000Z",
            "content_html": "<h2 id=\"docker安装centos\"><a class=\"anchor\" href=\"#docker安装centos\">#</a> docker 安装 (centos)</h2>\n<p>docker 引擎安装官网地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvY2VudG9zLw==\">Install Docker Engine on CentOS | Docker Documentation</span></p>\n<h3 id=\"手动安装\"><a class=\"anchor\" href=\"#手动安装\">#</a> 手动安装</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 卸载旧版本</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> yum remove <span class=\"token function\">docker</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                  docker-client <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                  docker-client-latest <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                  docker-common <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                  docker-latest <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                  docker-latest-logrotate <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                  docker-logrotate <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                  docker-engine</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 安装依赖工具</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> yum-utils</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 添加 docker 官方源</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">sudo</span> yum-config-manager <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    --add-repo <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    https://download.docker.com/linux/centos/docker-ce.repo</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\"># 查询可安装版本</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\"># yum list docker-ce --showduplicates | sort -r</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\"># 安装特定版本</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\"># sudo yum install docker-ce-&lt;VERSION_STRING> docker-ce-cli-&lt;VERSION_STRING> containerd.io docker-compose-plugin</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\"># 安装 docker</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> docker-ce docker-ce-cli containerd.io docker-compose-plugin</pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\"># 启动 docker 服务</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>systemctl start <span class=\"token function\">docker</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\"># 添加开机自启动</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>systemctl <span class=\"token builtin class-name\">enable</span> <span class=\"token function\">docker</span></pre></td></tr></table></figure><h3 id=\"脚本安装\"><a class=\"anchor\" href=\"#脚本安装\">#</a> 脚本安装</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://get.docker.com <span class=\"token parameter variable\">-o</span> get-docker.sh</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token function\">sudo</span> <span class=\"token function\">sh</span> get-docker.sh</pre></td></tr></table></figure><h2 id=\"阿里云镜像加速\"><a class=\"anchor\" href=\"#阿里云镜像加速\">#</a> 阿里云镜像加速</h2>\n<p>登录阿里云，进入容器镜像服务 -&gt; 镜像加速器，复制代码在系统中执行即可<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221015211053.png\" alt=\"\" /></p>\n<h2 id=\"docker卸载\"><a class=\"anchor\" href=\"#docker卸载\">#</a> docker 卸载</h2>\n<ol>\n<li>\n<p>卸载 Docker 引擎、CLI、Containerd 和 Docker Compose 包：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin</pre></td></tr></table></figure></li>\n<li>\n<p>主机上的映像、容器、卷或自定义配置文件不会自动删除。删除所有映像、容器和卷：</p>\n<pre><code class=\"language-b\">sudo rm -rf /var/lib/docker\nsudo rm -rf /var/lib/containerd\n</code></pre>\n<blockquote>\n<p>您必须手动删除任何已编辑的配置文件。</p>\n</blockquote>\n</li>\n</ol>\n",
            "tags": [
                "软件安装",
                "docker"
            ]
        },
        {
            "id": "http://licwuu.github.io/blog/github-picgo-jsdelvr%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/",
            "url": "http://licwuu.github.io/blog/github-picgo-jsdelvr%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/",
            "title": "github+picgo+jsdelvr搭建免费图床",
            "date_published": "2022-10-14T15:00:33.000Z",
            "content_html": "<p>如果我们平时写博客用的是 markdown 来进行编写，肯定会遇到图片的存储问题。如果放在本地，文章发送给别人看，图片将无法解析出来，这时候就需要用到图床 —— 一种在云端上存储图片的服务器，提供链接供我们访问图片，我们只需要在文章中插入对应链接即可实现一次储存，多地使用。本文将交大家如何利用 github+picGo 快速搭建免费图床，并使用 jsdelivr 免费做 CDN 加速。</p>\n<h2 id=\"github准备\"><a class=\"anchor\" href=\"#github准备\">#</a> github 准备</h2>\n<ol>\n<li>\n<p>准备一个图床仓库</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/default/20221014230729.png\" alt=\"新建图床仓库\" /></p>\n<blockquote>\n<p>很多博客教学让克隆 Github 仓库到本地和发布仓库 Release，其实如果仅仅作为图床使用可以不用做这几步操作。</p>\n</blockquote>\n</li>\n<li>\n<p>获取 github 的 Token 授权，后面 picgo 需要用到</p>\n<p>在 github-&gt;setting-&gt;Developer settings 的 Personal access tokens 中点击 Generate new token 生成新的 Token<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/default/20221014231554.png\" alt=\"token位置\" /><br />\n填写 Token 相关信息，Note 是 Token 的名字，随意就好，Expiration 是 Token 过期时间，建议设置为 No expiration，也就是永不过期，权限勾选下图中这几个就行，也可以根据自己情况勾选，然后点击最下方的 Generate Token。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/default/20221014232012.png\" alt=\"生成新token\" /><br />\n 界面这个位置会显示生成的 Token，请复制保存好，它只会显示一次。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/default/20221014232550.png\" alt=\"Token\" /></p>\n</li>\n</ol>\n<h2 id=\"picgo准备\"><a class=\"anchor\" href=\"#picgo准备\">#</a> Picgo 准备</h2>\n<ol>\n<li>\n<p>去<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dvL3JlbGVhc2Vz\"> picgo GitHub 仓库</span>下载对应版本的安装包安装</p>\n</li>\n<li>\n<p>打开 Picgo 软件，点击图床配置，选择 GitHub 图床，填写相关配置</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/default/20221014233301.png\" alt=\"picgo配置\" /></p>\n</li>\n</ol>\n<ul>\n<li>设定仓库名：你的 <code>github名/仓库名</code></li>\n<li>设定分支名：main</li>\n<li>设定 Token：前面获取的 Github Token</li>\n<li>指定存储路径：相当于在仓库里的文件夹路径</li>\n<li>设定自定义域名：我们采用 jsdelivr 作 CDN 加速，因此这里填写的域名根据 jsdelivr 的规则应该是 <code>https://cdn.jsdelivr.net/gh/你的GitHub名/你的仓库名</code> ，详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tLw==\"> jsdelivr 官网</span>。</li>\n</ul>\n<p>欧克，到此，你已经拥有了一个属于你自己的图床，点击上传区即可上传图片到图床，picGo 会返回对应的图片链接，并且提供多种链接格式可以选择。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/default/20221015111143.png\" alt=\"image-20221015095706548\" /></p>\n<h2 id=\"typaro一种简介方便的markdown编辑器\"><a class=\"anchor\" href=\"#typaro一种简介方便的markdown编辑器\">#</a> Typaro（一种简介方便的 markdown 编辑器）</h2>\n<p>如果你使用 Typaro 进行文章编写，可以在文件 -&gt; 偏好设置 -&gt; 图像里面配置 PicGo 进行图片上传，只需在填入 picGo 对应路径即可。现在你就可以直接使用 CV 大法直接插入图片了，图片会自动上传图床。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/images/default/image-20221015095952444.png\" alt=\"image-20221015095952444\" /></p>\n",
            "tags": [
                "default",
                "default"
            ]
        },
        {
            "id": "http://licwuu.github.io/blog/redis%E5%AD%A6%E4%B9%A0/",
            "url": "http://licwuu.github.io/blog/redis%E5%AD%A6%E4%B9%A0/",
            "title": "redis学习",
            "date_published": "2022-10-13T12:48:01.000Z",
            "content_html": "<h2 id=\"redis简介\"><a class=\"anchor\" href=\"#redis简介\">#</a> Redis 简介</h2>\n<p>NoSQL (NoSQL = Not Only SQL)，意即 “不仅仅是 SQL”，泛指非关系型的数据库。NoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。Redis 就是典型的、也是常用的 NoSql 之一。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>不遵循 SQL 标准。</li>\n<li>不支持 ACID。</li>\n<li>远超于 SQL 的性能。</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>对数据高并发的读写</li>\n<li>海量数据的读写</li>\n<li>对数据高可扩展性的</li>\n<li><strong>用不着 sql 的和用了 sql 也不行的情况，请考虑用 NoSql</strong></li>\n</ul>\n<p><strong>不适用场景：</strong></p>\n<ul>\n<li>需要事务支持</li>\n<li>基于 sql 的结构化查询存储，处理复杂的关系，需要即席查询</li>\n</ul>\n<h2 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h2>\n<p>一般 Redis 都是部署在 Linux 环境中，因此不考虑在 windows 中部署。</p>\n<ol>\n<li>\n<p>准备 C 语言环境</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum <span class=\"token function\">install</span> centos-release-scl scl-utils-build</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>yum <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> devtoolset-8-toolchain</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>scl <span class=\"token builtin class-name\">enable</span> devtoolset-8 <span class=\"token function\">bash</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 测试 GCC</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>gcc <span class=\"token parameter variable\">--version</span></pre></td></tr></table></figure><p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221013210915.png\" alt=\"测试GCC\" /></p>\n</li>\n<li>\n<p>去<span class=\"exturl\" data-url=\"aHR0cDovL3JlZGlzLmlv\"> Redis 官网</span>下载对应的安装包，一般 Redis 都是部署在 Linux 环境中，即下载 for Linux (redis-xxx.tar.gz），放 /opt 目录</p>\n</li>\n<li>\n<p>解压安装</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">tar</span> <span class=\"token parameter variable\">-zxvf</span> redis-6.2.1.tar.gz</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> redis-6.2.1</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">make</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">make</span> <span class=\"token function\">install</span></pre></td></tr></table></figure><blockquote>\n<p>如果没有准备好 C 语言编译环境，make 会报错 (Jemalloc/jemalloc.h：没有那个文件), 只需要执行 <code>make distclean</code>  后重新执行 <code>make</code>  命令即可。</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>默认安装目录：</strong>/usr/local/bin<br />\n 查看默认安装目录常用命令：</p>\n<ul>\n<li>redis-benchmark: 性能测试工具，可以在自己本子运行，看看自己本子性能如何</li>\n<li>redis-check-aof：修复有问题的 AOF 文件，rdb 和 aof 后面讲</li>\n<li>redis-check-dump：修复有问题的 dump.rdb 文件</li>\n<li>redis-sentinel：Redis 集群使用</li>\n<li>redis-server：Redis 服务器启动命令</li>\n<li>redis-cli：客户端，操作入口</li>\n</ul>\n<h2 id=\"启动\"><a class=\"anchor\" href=\"#启动\">#</a> 启动</h2>\n<h3 id=\"前台启动\"><a class=\"anchor\" href=\"#前台启动\">#</a> 前台启动</h3>\n<p>在安装目录下运行 <code>redis-srver</code>  即可。</p>\n<h3 id=\"后台启动\"><a class=\"anchor\" href=\"#后台启动\">#</a> 后台启动</h3>\n<ol>\n<li>\n<p>编写配置文件</p>\n<p>拷贝一份 redis.conf 到其他目录: <code>cp  /opt/redis-3.2.5/redis.conf  /myredis</code> , 更改配置文件 daemonize no 改成 yes。</p>\n</li>\n<li>\n<p>通过配置文件启动，执行 <code>redis-server /myredis/redis.conf</code></p>\n</li>\n</ol>\n<h3 id=\"客户端连接\"><a class=\"anchor\" href=\"#客户端连接\">#</a> 客户端连接</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>redis-cli <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6379</span> <span class=\"token comment\"># -p 6379 可省略</span></pre></td></tr></table></figure><h3 id=\"redis关闭\"><a class=\"anchor\" href=\"#redis关闭\">#</a> redis 关闭</h3>\n<ol>\n<li>redis-cli 连接后使用 shutdown 命令关闭，或者直接 redis-cli -p 6379 shutdown</li>\n<li>kill -9 进程号</li>\n</ol>\n<h2 id=\"redis命令网站1\"><a class=\"anchor\" href=\"#redis命令网站1\">#</a> <span class=\"exturl\" data-url=\"aHR0cDovL3JlZGlzZG9jLmNvbS9pbmRleC5odG1s\">Redis 命令网站 1</span>、<span class=\"exturl\" data-url=\"aHR0cDovL2RvYy5yZWRpc2ZhbnMuY29tLw==\">Redis 命令网站 2</span></h2>\n<h2 id=\"redis数据类型\"><a class=\"anchor\" href=\"#redis数据类型\">#</a> Redis 数据类型</h2>\n<h3 id=\"0-redis-键key\"><a class=\"anchor\" href=\"#0-redis-键key\">#</a> 0. Redis 键（key）</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>keys * <span class=\"token comment\"># 查看当前库所有 key (匹配：keys *1)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>exists key <span class=\"token comment\"># 判断某个 key 是否存在</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">type</span> key <span class=\"token comment\"># 查看你的 key 对应的值是什么类型</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>del key <span class=\"token comment\"># 删除指定的 key 数据</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>unlink key <span class=\"token comment\"># 根据 value 选择非阻塞删除，仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作。</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>expire key <span class=\"token number\">10</span> <span class=\"token comment\"># 10 秒钟：为给定的 key 设置过期时间</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>ttl key <span class=\"token comment\"># 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">select</span> n <span class=\"token comment\"># 命令切换数据库 n</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>dbsize <span class=\"token comment\"># 查看当前数据库的 key 的数量</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>flushdb <span class=\"token comment\"># 清空当前库</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>flushall <span class=\"token comment\"># 清空全部库</span></pre></td></tr></table></figure><h3 id=\"1-字符串string\"><a class=\"anchor\" href=\"#1-字符串string\">#</a> 1. 字符串（String）</h3>\n<h4 id=\"string简介\"><a class=\"anchor\" href=\"#string简介\">#</a> String 简介</h4>\n<p>String 是 Redis 最基本的类型，一个 key 对应一个 value，类似于 Map&lt;String,Object&gt;。String 类型是二进制安全的，意味着 Redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。String 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value<strong> 最多可以是 512M</strong>。</p>\n<h4 id=\"string常用命令\"><a class=\"anchor\" href=\"#string常用命令\">#</a> String 常用命令</h4>\n<ol>\n<li>\n<p><code>set key value [EX seconds|PX milliseconds |KEEPTTL] [NX|XX]</code>  添加键值对</p>\n<p>NX：当数据库中 key 不存在时，可以将 key-value 添加数据库</p>\n<p>XX：当数据库中 key 存在时，可以将 key-value 添加数据库，与 NX 参数互斥</p>\n<p>EX：key 的超时秒数</p>\n<p>PX：key 的超时毫秒数，与 EX 互斥</p>\n</li>\n<li>\n<p><code>get  key</code>  查询对应键值</p>\n</li>\n<li>\n<p><code>append key</code>  value 将给定的 value  追加到原值的末尾</p>\n</li>\n<li>\n<p><code>strlen key</code>  获得值的长度</p>\n</li>\n<li>\n<p><code>setnx key value</code>  只有在 key 不存在时才能设置 key 的值，后面可以利用这个特性将其作为分布式锁</p>\n</li>\n<li>\n<p><code>incr key</code>  将 key 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1</p>\n</li>\n<li>\n<p><code>decr key</code>  将 key 中储存的数字值减，只能对数字值操作，如果为空，新增值为 - 1</p>\n</li>\n<li>\n<p><code>incrby/decrby key n</code>  将 key 中储存的数字值增减 n (自定义步长)</p>\n<blockquote>\n<p>redis 中的 incr/decr 不同于 java 中的 i++，它是原子操作。</p>\n</blockquote>\n</li>\n<li>\n<p><code>mset key1 value1 key2 value2 .....</code>  同时设置一个或多个 key-value 队</p>\n</li>\n<li>\n<p><code>mget key1 key2 key3 .....</code>  同时获取一个或多个 value</p>\n</li>\n<li>\n<p><code>msetnx key1 value1 key2 value2  .....</code>  同时设置一个或多个 key-value 队，当且仅当所有给定 key 都不存在才成功，该操作具有原子性，有一个失败则都失败</p>\n</li>\n<li>\n<p><code>getrange key start end</code>  命令用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)</p>\n</li>\n<li>\n<p><code>setrange  key start value</code>  指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 start 开始</p>\n</li>\n<li>\n<p><code>setex  key 过期时间 value</code>  设置键值的同时，设置过期时间，单位秒。</p>\n</li>\n<li>\n<p><code>getset key value</code>  以新换旧，设置了新值同时获得旧值。</p>\n</li>\n</ol>\n<h4 id=\"string数据结构\"><a class=\"anchor\" href=\"#string数据结构\">#</a> String 数据结构</h4>\n<p>String 的数据结构为简单动态字符串 (Simple Dynamic String, 缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221013221244.png\" alt=\"String数据结构\" /><br />\n如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>\n<h3 id=\"2-列表list\"><a class=\"anchor\" href=\"#2-列表list\">#</a> 2. 列表 (List)</h3>\n<h4 id=\"list简介\"><a class=\"anchor\" href=\"#list简介\">#</a> List 简介</h4>\n<p>Redis 列表是简单的字符串列表 (单键多值)，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br />\n它的底层实际是个双向快速链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>\n<h4 id=\"list常用命令\"><a class=\"anchor\" href=\"#list常用命令\">#</a> List 常用命令</h4>\n<ol>\n<li><code>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt; ....</code>  从左边 / 右边插入一个或多个值。</li>\n<li><code>lpop/rpop &lt;key&gt;</code>  从左边 / 右边吐出一个值。值在键在，值光键亡。</li>\n<li><code>rpoplpush &lt;key1&gt; &lt;key2&gt;</code>  从 key1 列表右边吐出一个值，插到 key2 列表左边。</li>\n<li><code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code>  按照索引下标获得元素 (从左到右)，负数从右到左计数</li>\n<li><code>lindex &lt;key&gt;&lt;index&gt;</code>  按照索引下标获得元素 (从左到右)</li>\n<li><code>llen &lt;key&gt;</code>  获得列表长度</li>\n<li><code>linsert &lt;key&gt; before &lt;value&gt; &lt;newvalue&gt;</code>  在 value 的前面插入 newvalue</li>\n<li><code>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</code>  从左边删除 n 个 value (从左到右)</li>\n<li><code>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</code>  将列表 key 下标为 index 的值替换成 value</li>\n</ol>\n<h4 id=\"list数据结构\"><a class=\"anchor\" href=\"#list数据结构\">#</a> List 数据结构</h4>\n<p>List 的数据结构为快速链表 quickList。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221013224949.png\" alt=\"redis列表数据结构\" /></p>\n<h3 id=\"3-集合set\"><a class=\"anchor\" href=\"#3-集合set\">#</a> 3. 集合 (Set)</h3>\n<h4 id=\"set简介\"><a class=\"anchor\" href=\"#set简介\">#</a> Set 简介</h4>\n<p>Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动<strong>排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p>\n<p>Redis 的 Set 是 string 类型的无序集合。它底层其实是一个 value 为 null 的 hash 表，所以添加，删除，查找的<strong>复杂度都是 O (1)</strong>。</p>\n<p><strong>常用命令参考：</strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5jd25lc3QudG9wL3NldC9pbmRleC5odG1s\">Redis Set 命令</span></p>\n<h4 id=\"set数据结构\"><a class=\"anchor\" href=\"#set数据结构\">#</a> Set 数据结构</h4>\n<p>Set 数据结构是 dict 字典，字典是用<strong>哈希表</strong>实现的。</p>\n<p>Java 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。Redis 的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向同一个内部值。</p>\n<h3 id=\"4-哈希hash\"><a class=\"anchor\" href=\"#4-哈希hash\">#</a> 4. 哈希 (Hash)</h3>\n<h4 id=\"hash简介\"><a class=\"anchor\" href=\"#hash简介\">#</a> Hash 简介</h4>\n<p>Redis hash 是一个键值对集合。</p>\n<p>Redis hash 的 key 是一个 string 类型，值是一个 field 和 value 的映射表，它特别适合用于存储对象 (类似 Java 里面的 Map&lt;String,Object&gt;)。比如：用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，有以下的存储方式：</p>\n<ol>\n<li>\n<p>每次修改用户的某个属性需要，先反序列化改好后再序列化回去，<strong>开销较大</strong>。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014102051.png\" alt=\"序列化方式\" /></p>\n</li>\n<li>\n<p>通过用户 ID 加属性标签构造不同 key,<strong> 用户 ID 数据冗余</strong>。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014102237.png\" alt=\"构造不同key\" /></p>\n</li>\n<li>\n<p>通过 key (用户 ID) + field (属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014102309.png\" alt=\"hash结构存储\" /></p>\n</li>\n</ol>\n<p><strong>常用命令参考：</strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5jd25lc3QudG9wL2hhc2gvaW5kZXguaHRtbA==\">Redis Hash 命令</span></p>\n<h4 id=\"hash数据结构\"><a class=\"anchor\" href=\"#hash数据结构\">#</a> Hash 数据结构</h4>\n<p>Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。</p>\n<h3 id=\"5-有序集合zsetsorted-set\"><a class=\"anchor\" href=\"#5-有序集合zsetsorted-set\">#</a> 5. 有序集合 Zset (sorted set)</h3>\n<h4 id=\"zset-简介\"><a class=\"anchor\" href=\"#zset-简介\">#</a> Zset 简介</h4>\n<p>Redis 有序集合 zset 为每个成员都关联了一个评分（score）, 这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是<strong>唯一</strong>的，但是<strong>评分可以是重复</strong>的 。</p>\n<p>因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>\n<p><strong>常用命令参考：</strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5jd25lc3QudG9wL3NvcnRlZF9zZXQvaW5kZXguaHRtbA==\">Redis Zset 命令</span></p>\n<h4 id=\"zset数据结构\"><a class=\"anchor\" href=\"#zset数据结构\">#</a> Zset 数据结构</h4>\n<p>SortedSet (zset) 是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</p>\n<p>zset 底层使用了两个数据结构：</p>\n<ol>\n<li>**Hash：**hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</li>\n<li>** 跳跃表：** 跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</li>\n</ol>\n<h4 id=\"什么是跳跃表\"><a class=\"anchor\" href=\"#什么是跳跃表\">#</a> 什么是跳跃表</h4>\n<p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>\n<p>** 实例：** 对比有序链表和跳跃表，从链表中查询出 51</p>\n<ol>\n<li>\n<p>有序链表</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014103750.png\" alt=\"有序链表\" /></p>\n<p>要查找值为 51 的元素，需要从第一个元素开始依次查找、比较才能找到。共需要 6 次比较。</p>\n</li>\n<li>\n<p>跳跃表</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014103839.png\" alt=\"跳跃表\" /></p>\n<p>从第 2 层开始，1 节点比 51 节点小，向后比较。</p>\n<p>21 节点比 51 节点小，继续向后比较，后面就是 NULL 了，所以从 21 节点向下到第 1 层</p>\n<p>在第 1 层，41 节点比 51 节点小，继续向后，61 节点比 51 节点大，所以从 41 向下</p>\n<p>在第 0 层，51 节点为要查找的节点，节点被找到，共查找 4 次。</p>\n</li>\n</ol>\n<p>从此可以看出跳跃表比有序链表效率要高。</p>\n<h3 id=\"bitmaps\"><a class=\"anchor\" href=\"#bitmaps\">#</a> Bitmaps</h3>\n<h4 id=\"bitmaps简介\"><a class=\"anchor\" href=\"#bitmaps简介\">#</a> Bitmaps 简介</h4>\n<p>Redis 提供了 Bitmaps 这个 “数据类型” 可以实现对位的操作，合理地使用操作位能够有效地提高内存使用率和开发效率。Bitmaps 本身不是一种数据类型，实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。Bitmaps 单独提供了一套命令，所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同，可以把 Bitmaps 想象成一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标在 Bitmaps 中叫做偏移量。</p>\n<h4 id=\"使用样例\"><a class=\"anchor\" href=\"#使用样例\">#</a> 使用样例</h4>\n<p>每个独立用户是否访问过网站存放在 Bitmaps 中， 将访问的用户记做 1， 没有访问的用户记做 0， 用偏移量作为用户的 id。设置键的第 offset 个位的值（从 0 算起） ， 假设现在有 20 个用户，userid=1， 6， 11， 15， 19 的用户对网站进行了访问， 那么当前 Bitmaps 初始化结果如图：<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221015141156.png\" alt=\"20221015141156\" /><br />\nbitmap 还可以进行复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在目标 key 中。</p>\n<p>注：很多应用的用户 id 以一个指定数字（例如 10000） 开头，直接将用户 id 和 Bitmaps 的偏移量对应势必会造成一定的浪费，通常的做法是每次做 setbit 操作时将用户 id 减去这个指定数字。在第一次初始化 Bitmaps 时，假如偏移量非常大，那么整个初始化过程执行会比较慢， 可能会造成 Redis 的阻塞。</p>\n<h4 id=\"bitmaps与set对比\"><a class=\"anchor\" href=\"#bitmaps与set对比\">#</a> Bitmaps 与 set 对比</h4>\n<p>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">每个用户 id 占用空间</th>\n<th style=\"text-align:center\">需要存储的用户量</th>\n<th style=\"text-align:center\">全部内存量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">集合类型</td>\n<td style=\"text-align:center\">64 位</td>\n<td style=\"text-align:center\">50000000</td>\n<td style=\"text-align:center\">64 位 * 50000000 = 400MB</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Bitmaps</td>\n<td style=\"text-align:center\">1 位</td>\n<td style=\"text-align:center\">100000000</td>\n<td style=\"text-align:center\">1 位 * 100000000 = 12.5MB</td>\n</tr>\n</tbody>\n</table>\n<p>很明显， 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">一天</th>\n<th style=\"text-align:center\">一个月</th>\n<th>一年</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">集合类型</td>\n<td style=\"text-align:center\">400MB</td>\n<td style=\"text-align:center\">12GB</td>\n<td>144GB</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Bitmaps</td>\n<td style=\"text-align:center\">12.5MB</td>\n<td style=\"text-align:center\">375MB</td>\n<td>4.5GB</td>\n</tr>\n</tbody>\n</table>\n<p>但 Bitmaps 并不是万金油，假如该网站每天的独立访问用户很少，例如只有 10 万（大量的僵尸用户），那么两者的对比如下表所示，很显然，这时候使用 Bitmaps 就不太合适了，因为基本上大部分位都是 0</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">每个 userid 占用空间</th>\n<th style=\"text-align:center\">需要存储的用户量</th>\n<th style=\"text-align:center\">全部内存量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">集合类型</td>\n<td style=\"text-align:center\">64 位</td>\n<td style=\"text-align:center\">100000</td>\n<td style=\"text-align:center\">64 位 * 100000 = 800KB</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Bitmaps</td>\n<td style=\"text-align:center\">1 位</td>\n<td style=\"text-align:center\">100000000</td>\n<td style=\"text-align:center\">1 位 * 100000000 = 12.5MB</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"hyperloglog\"><a class=\"anchor\" href=\"#hyperloglog\">#</a> HyperLogLog</h3>\n<p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量）, 可以使用 Redis 的 incr、incrby 轻松实现。但像 UV（UniqueVisitor，独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>\n<p>解决基数问题有很多种方案：</p>\n<ol>\n<li>数据存储在 MySQL 表中，使用 distinct count 计算不重复个数</li>\n<li>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理</li>\n</ol>\n<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>\n<p>能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog</p>\n<p>Redis HyperLogLog 是用来做基数统计的算法。HyperLogLog 在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>\n<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>\n<blockquote>\n<p>什么是基数？<br />\n 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数 (不重复元素) 为 5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>\n</blockquote>\n<h3 id=\"geospatial\"><a class=\"anchor\" href=\"#geospatial\">#</a> Geospatial</h3>\n<p>Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。如：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 添加城市经纬度</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>geoadd china:city <span class=\"token number\">106.50</span> <span class=\"token number\">29.53</span> chongqing <span class=\"token number\">114.05</span> <span class=\"token number\">22.52</span> shenzhen <span class=\"token number\">116.38</span> <span class=\"token number\">39.90</span> beijing </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 计算城市距离 geodist&lt;key>&lt;member1>&lt;member2>  [m|km|ft|mi]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>geodist china:city chongqing shenzhen  km</pre></td></tr></table></figure><h2 id=\"redis配置文件常用配置介绍\"><a class=\"anchor\" href=\"#redis配置文件常用配置介绍\">#</a> Redis 配置文件常用配置介绍</h2>\n<p><strong>requirepass</strong>：设置密码（！！！）</p>\n<p><strong>Unit 单元</strong>：配置大小单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit，大小写不敏感</p>\n<p><strong>INCLUDES 包含</strong>：多实例的情况可以把公用的配置文件提取出来，通过 <code>include /对应路径</code> 应用过来即可</p>\n<p><strong>bind</strong>：绑定接受谁的访问请求。默认配置是 <code>bind=127.0.0.1</code>  只接受本机请求，如果不设定且 <code>protected-mode no</code> ，则是无限制接受任何 ip 地址的访问</p>\n<p><strong>protected-mode</strong>：如果开启了 protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，Redis 只允许接受本机的响应，默认开启</p>\n<p><strong>port</strong>：启动端口号，默认 6379</p>\n<p><strong>tcp-backlog</strong>：设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和 = 未完成三次握手队列 + 已经完成三次握手队列。</p>\n<blockquote>\n<p>在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题。注意 Linux 内核会将这个值减小到 /proc/sys/net/core/somaxconn 的值（128），所以需要确认增大 /proc/sys/net/core/somaxconn 和 /proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>\n</blockquote>\n<p><strong>timeout</strong>：设定一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能，即永不关闭</p>\n<p><strong>tcp-keepalive n</strong>: 对访问客户端的一种心跳检测，每 n 秒检测一次。</p>\n<p><strong>daemonzie</strong>: 是否后台启动，建议 yes</p>\n<p><strong>pidfile</strong>：设置存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件</p>\n<p><strong>loglevel</strong>：设置日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</p>\n<p><strong>logfile</strong>：设置日志文件名称</p>\n<p><strong>databases</strong>：设定库的数量，默认 16</p>\n<p><strong>maxclients</strong>：设置 redis 同时可以与多少个客户端进行连接，默认情况下为 10000 个客户端，如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出 “max number of clients reached” 以作回应</p>\n<p><strong>maxmemory</strong>：设置 redis 可以使用的内存量。一旦到达内存使用上限，redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定</p>\n<blockquote>\n<p>建议必须设置，否则，将内存占满，造成服务器宕机<br />\n如果 redis 无法根据移除规则来移除内存中的数据，或者设置了 “不允许移除”，那么 redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等<br />\n但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。如果你的 redis 是主 redis（说明你的 redis 有从 redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是 “不移除” 的情况下，才不用考虑这个因素。</p>\n</blockquote>\n<p><strong>maxmemory-policy</strong>: 指定 maxmemory 的移除规则，有以下几种：</p>\n<ol>\n<li>volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；（最近最少使用）</li>\n<li>allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key</li>\n<li>volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</li>\n<li>allkeys-random：在所有集合 key 中，移除随机的 key</li>\n<li>volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key</li>\n<li>noeviction (默认)：不进行移除。针对写操作，只是返回错误信息</li>\n</ol>\n<h2 id=\"redis的发布和订阅\"><a class=\"anchor\" href=\"#redis的发布和订阅\">#</a> Redis 的发布和订阅</h2>\n<h3 id=\"什么是发布订阅\"><a class=\"anchor\" href=\"#什么是发布订阅\">#</a> 什么是发布订阅</h3>\n<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息 (观察者模式)。</p>\n<p>Redis 客户端可以订阅频道如下图右侧 (可以订阅任意数量的频道), 当发布者给这个频道发布消息后，消息就会发送给订阅的客户端</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014113540.png\" alt=\"发布订阅样例\" /></p>\n<h3 id=\"命令行实现\"><a class=\"anchor\" href=\"#命令行实现\">#</a> 命令行实现</h3>\n<ol>\n<li>打开一个客户端订阅 channel1： <code>SUBSCRIBE channel1</code></li>\n<li>打开另一个客户端，给 channel1 发布消息 hello： <code>publish channel1 hello</code> , 返回的 1 是订阅者数量</li>\n<li>在第一个客户端可以看到发送的消息</li>\n</ol>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014114349.png\" alt=\"发布订阅实现样例\" /></p>\n<blockquote>\n<p>注：发布的消息没有持久化，如果在订阅的客户端没有收到 hello，那就只能收到之后发布的消息</p>\n</blockquote>\n<h2 id=\"redis事务\"><a class=\"anchor\" href=\"#redis事务\">#</a> redis 事务</h2>\n<h3 id=\"事务定义\"><a class=\"anchor\" href=\"#事务定义\">#</a> 事务定义</h3>\n<p>Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断，其主要作用就是串联多个命令防止别的命令插队。</p>\n<p>redis 中事务和 mysql 中事务不太像一个概念；redis 中事务通过组队完成多个命令的绑定操作，是为了防止别的命令插队，不会回滚。</p>\n<h3 id=\"事务命令multi-exec-discard\"><a class=\"anchor\" href=\"#事务命令multi-exec-discard\">#</a> 事务命令 (Multi、Exec、discard)</h3>\n<p>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行，组队的过程中可以通过 discard 来放弃组队。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014150423.png\" alt=\"事务组队过程\" /></p>\n<h3 id=\"事务错误处理\"><a class=\"anchor\" href=\"#事务错误处理\">#</a> 事务错误处理</h3>\n<ol>\n<li>\n<p>在组队过程中出现错误（如语法错误）会立即提示，不修改命令直接使用 exec 执行，所有组队的命令都无法执行；</p>\n</li>\n<li>\n<p>在组队阶段成功，在执行阶段发生错误，只有错误命令不执行，其他命令照常执行，<strong>不会回滚</strong>；</p>\n</li>\n</ol>\n<h3 id=\"事务冲突\"><a class=\"anchor\" href=\"#事务冲突\">#</a> 事务冲突</h3>\n<p>样例：有多个人拥有你的账户，同时对其操作就会产生事务冲突。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221010195207412.png\" alt=\"image-20221010195207412\" /></p>\n<p>解决方案：</p>\n<p><strong>悲观锁</strong>：假想每次拿数据后原有数据都会被修改，所以，每次拿数据都给数据上锁，使得别人无法操作该数据。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014162312.png\" alt=\"悲观锁\" /></p>\n<blockquote>\n<p>tips: 传统关系型数据库的行锁、表锁等都是这种方式。但是这种方式效率很慢。</p>\n</blockquote>\n<p>** 乐观锁：** 给数据加上一个标识，如版本号等，拿到数据进行操作后，查看现在数据和之前拿到的版本号是否一致；不一致则说明有人操作过数据，需要重新读取数据再进行操作；一致则说明操作期间没人动过数据，直接更新数据和更改版本号即可。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis 就是利用这种 check-and-set 机制实现事务的。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014162329.png\" alt=\"乐观锁\" /></p>\n<p>**redis 中通过 watch 命令监听 key 实现乐观锁:**WATCH key [key ...] ，unwatch 命令可以取消监听。</p>\n<p>在执行 multi 之前，先执行 watch key1 [key2], 可以监视一个 (或多个) key ，如果在事务<strong>执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断。</strong></p>\n<h3 id=\"事务三大特性\"><a class=\"anchor\" href=\"#事务三大特性\">#</a> 事务三大特性</h3>\n<ol>\n<li><strong>单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li>\n<li><strong>没有隔离级别的概念</strong>：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li>\n<li><strong>不保证原子性</strong>：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>\n</ol>\n<h2 id=\"redis持久化\"><a class=\"anchor\" href=\"#redis持久化\">#</a> Redis 持久化</h2>\n<h3 id=\"1-rdbredis-database\"><a class=\"anchor\" href=\"#1-rdbredis-database\">#</a> 1. RDB(redis database)</h3>\n<h4 id=\"什么是rdb\"><a class=\"anchor\" href=\"#什么是rdb\">#</a> 什么是 RDB</h4>\n<p>RDB 是指在指定的时间间隔内将内存中的数据集快照写入磁盘 —— 快照（Snapshot），它恢复时是将快照文件直接读到内存里，redis 会<strong>默认开启 rdb</strong>，并将备份文件保存在./dump.rdb 中</p>\n<h4 id=\"rdb执行流程\"><a class=\"anchor\" href=\"#rdb执行流程\">#</a> RDB 执行流程</h4>\n<p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。<strong>RDB 的缺点是最后一次持久化后的数据可能丢失</strong>。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014170805.png\" alt=\"RDB执行流程\" /></p>\n<blockquote>\n<p>Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>\n<p>在 Linux 程序中，fork () 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux 中引入了 “<strong>写时复制技术</strong>”</p>\n<p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>\n</blockquote>\n<h4 id=\"save-bgsave\"><a class=\"anchor\" href=\"#save-bgsave\">#</a> save &amp;&amp; bgsave</h4>\n<p>RDB 采用写时复制技术在指定时间间隔将 redis 数据同步到磁盘中，有 save 和 bgsave 两种配置，推荐采用 bgsave 操作。因为 save 操作会阻塞，而 bgsave 是异步的。</p>\n<p>格式： <code>save 秒钟 写操作次数</code></p>\n<p>如：save 10 1000 则表示 10s 内有 1000 次写操作，就触发备份。</p>\n<h4 id=\"rdb备份与恢复\"><a class=\"anchor\" href=\"#rdb备份与恢复\">#</a> RDB 备份与恢复</h4>\n<p>备份：先通过 config get dir 查询 rdb 文件的目录 ，将 *.rdb 的文件拷贝到别的地方即可。</p>\n<p>恢复：先把备份的文件拷贝到工作目录下  <code>cp 备份文件路径 dump.rdb</code> , 再启动 Redis, 备份数据会直接加载。</p>\n<h4 id=\"rdb优势\"><a class=\"anchor\" href=\"#rdb优势\">#</a> RDB 优势</h4>\n<ul>\n<li>适合大规模的数据恢复</li>\n<li>对数据完整性和一致性要求不高更适合使用</li>\n<li>节省磁盘空间</li>\n<li>恢复速度快</li>\n</ul>\n<h4 id=\"rdb劣势\"><a class=\"anchor\" href=\"#rdb劣势\">#</a> RDB 劣势</h4>\n<ul>\n<li>Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</li>\n<li>虽然 Redis 在 fork 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能</li>\n<li>在备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照之后的所有修改。</li>\n</ul>\n<h3 id=\"2-aofappend-only-file\"><a class=\"anchor\" href=\"#2-aofappend-only-file\">#</a> 2. AOF(append only file)</h3>\n<h4 id=\"什么是aof\"><a class=\"anchor\" href=\"#什么是aof\">#</a> 什么是 AOF</h4>\n<p>AOF 以<strong>日志</strong>的形式来记录每个写操作（增量保存），将 Redis 执行过的所有写指令记录下来 (<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF<strong> 默认关闭，如果开启默认保存在./appendonly.aof</strong> 中。</p>\n<h4 id=\"执行流程\"><a class=\"anchor\" href=\"#执行流程\">#</a> 执行流程</h4>\n<ol>\n<li>客户端的请求写命令会被 append 追加到 AOF 缓冲区内；</li>\n<li>AOF 缓冲区根据 AOF 持久化策略 [always,everysec,no] 将操作 sync 同步到磁盘的 AOF 文件中；</li>\n<li>AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩 AOF 文件容量；</li>\n<li>Redis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的；</li>\n</ol>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/20221014172420.png\" alt=\"AOF持久化流程\" /></p>\n<blockquote>\n<p><strong>AOF 重写操作</strong>：当 aof 文件过大，达到设定阈值，redis 会对其进行重写压缩操作，将前面的指令转化为 RDB 文件的格式以减少磁盘占用，并记录转化后文件大小，下次在超过当前大小 100% 时再次触发重写操作。比如文件大小达到 64M 时触发了重写操作，压缩到了 60M，下次在达到 120M 时再次触发。</p>\n</blockquote>\n<h4 id=\"启动-备份-和恢复异常恢复\"><a class=\"anchor\" href=\"#启动-备份-和恢复异常恢复\">#</a> 启动、备份、和恢复（异常恢复）</h4>\n<p>启动：修改默认的 appendonly no，改为 yes</p>\n<p>备份：同 RDB 一样，都是拷贝备份文件</p>\n<p>恢复：将备份文件拷贝到 Redis 工作目录下，启动系统即加载</p>\n<p>异常恢复：如遇到<strong> AOF 文件损坏</strong>，可备份文件再通过 /usr/local/bin/<strong>redis-check-aof--fix appendonly.aof</strong> 进行恢复文件。重启 redis，然后重新加载</p>\n<h4 id=\"aof同步频率设置\"><a class=\"anchor\" href=\"#aof同步频率设置\">#</a> AOF 同步频率设置</h4>\n<p><code>appendfsync always</code> ：始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好</p>\n<p><code>appendfsync everysec</code> ：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>\n<p><code>appendfsync no</code> ：redis 不主动进行同步，把同步时机交给操作系统。</p>\n<h4 id=\"优势\"><a class=\"anchor\" href=\"#优势\">#</a> 优势</h4>\n<ul>\n<li>备份机制更稳健，丢失数据概率更低。</li>\n<li>可读的日志文本，通过操作 AOF 稳健，可以处理误操作。</li>\n</ul>\n<h4 id=\"劣势\"><a class=\"anchor\" href=\"#劣势\">#</a> 劣势</h4>\n<ul>\n<li>比起 RDB 占用更多的磁盘空间。</li>\n<li>恢复备份速度要慢。</li>\n<li>每次读写都同步的话，有一定的性能压力。</li>\n<li>存在个别 Bug，造成恢复不能。</li>\n</ul>\n<h3 id=\"怎么选择\"><a class=\"anchor\" href=\"#怎么选择\">#</a> 怎么选择？</h3>\n<ul>\n<li>官方建议两个都启用</li>\n<li>如果对数据不敏感，可以单独 RDB</li>\n<li>如果只做纯内存缓存可以都不使用</li>\n<li>不建议单独 AOF，可能有 Bug</li>\n</ul>\n<blockquote>\n<p>如果 AOF 和 RDB 同时开启，系统使用谁恢复数据？</p>\n<p>默认会使用 AOF 恢复数据。因为 AOF 数据还原度高吧，RDB 会丢失最后一次备份之后操作的数据。</p>\n</blockquote>\n<h4 id=\"官方建议\"><a class=\"anchor\" href=\"#官方建议\">#</a> 官方建议</h4>\n<ul>\n<li>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>\n<li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 redis 协议追加保存每次写的操作到文件末尾</li>\n<li>Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大</li>\n<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式.</li>\n<li>同时开启两种持久化方式</li>\n<li>在这种情况下，当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整.</li>\n<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。那要不要只使用 AOF 呢？</li>\n<li>建议不要，因为 RDB 更适合用于备份数据库 (AOF 在不断变化不好备份)， 快速重启，而且不会有 AOF 可能潜在的 bug，留着作为一个万一的手段。</li>\n<li>性能建议</li>\n</ul>\n<blockquote>\n<p>因为 RDB 文件只用作后备用途，建议只在 Slave 上持久化 RDB 文件，而且只要 15 分钟备份一次就够了，只保留 <code>save 900 1</code>  这条规则。<br />\n如果使用 AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只 load 自己的 AOF 文件就可以了。<br />\n代价，一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。<br />\n只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64M 太小了，可以设到 5G 以上。<br />\n默认超过原大小 100% 大小时重写可以改到适当的数值。</p>\n</blockquote>\n<h2 id=\"redis主从复制\"><a class=\"anchor\" href=\"#redis主从复制\">#</a> Redis 主从复制</h2>\n<h3 id=\"是什么\"><a class=\"anchor\" href=\"#是什么\">#</a> 是什么</h3>\n<p>主机数据更新后根据配置和策略，自动同步到备机的 master/slaver 机制，master 主写，slaver 主读，一般<strong>一主多从</strong> 。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221011094914723.png\" alt=\"image-20221011094914723\" /></p>\n<p><strong>优势</strong>：读写分离，性能扩展、容灾快速恢复</p>\n<h3 id=\"单机搭建一主两从\"><a class=\"anchor\" href=\"#单机搭建一主两从\">#</a> 单机搭建一主两从</h3>\n<p>在 redis 中更改以下配置，作为公共配置：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Appendonly no</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>daemonize <span class=\"token function\">yes</span></pre></td></tr></table></figure><p>编写多个不同配置文件（其他两个把 6379 改为别的端口，如 6380、6381），写入以下配置</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>include /myredis/redis.conf</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>pidfile /var/run/redis_6379.pid</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>port <span class=\"token number\">6379</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>dbfilename dump6379.rdb</pre></td></tr></table></figure><p>启动三台 redis 服务器，可以通过 <code>redis-cli -p 端口号</code> 分别登录三台服务器，使用 <code>info replication</code>  查看相关信息</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>redis-server redis6379.conf</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>redis-server redis6380.conf</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>redis-server redis6381.conf</pre></td></tr></table></figure><p>配置主从关系：<strong>配从不配主</strong>，连接要作为从机的服务器，输入 <code>slaveof &lt;主机ip&gt;&lt;主机port&gt;</code> ，主从关系建立。</p>\n<h3 id=\"常用主从搭建\"><a class=\"anchor\" href=\"#常用主从搭建\">#</a> 常用主从搭建</h3>\n<h4 id=\"一主两从\"><a class=\"anchor\" href=\"#一主两从\">#</a> 一主两从</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221011142451587.png\" alt=\"image-20221011142451587\" /></p>\n<ul>\n<li><strong>从服务器挂掉</strong>之后再次重启，并不会直接作为之前主服务器的从服务器，而是自己成为主服务器，独立出来。 要想重新加入之前的主从复制，需要重新执行 slaveof 命令加入。</li>\n<li><strong>主服务器挂掉</strong>之后，从服务器还是作为从服务器，原地待命，等主服务器重启之后，仍然保持原有主从关系。</li>\n</ul>\n<h4 id=\"薪火相传\"><a class=\"anchor\" href=\"#薪火相传\">#</a> 薪火相传</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221011142546642.png\" alt=\"image-20221011142546642\" /></p>\n<p>主从服务器挂掉之后关系转变和一主二从一样，风险是一旦某个 slave 宕机，该 slave 后面跟的 slave 都没法备份</p>\n<h4 id=\"反客为主\"><a class=\"anchor\" href=\"#反客为主\">#</a> 反客为主</h4>\n<p>当一个 master 宕机后，可以用 slaveof no one 命令（得手动操作，要自动完成得加入哨兵）将后面的从机变成主机，其后面的 slave 不用做任何修改。</p>\n<h3 id=\"主从复制原理\"><a class=\"anchor\" href=\"#主从复制原理\">#</a> 主从复制原理</h3>\n<ol>\n<li>Slave 启动成功连接到 master 后会发送一个 sync 命令</li>\n<li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master 将传送整个数据文件到 slave, 以完成一次完全同步</li>\n<li>全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>\n<li>增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave, 完成同步</li>\n<li>但是只要是重新连接 master, 一次完全同步（全量复制) 将被自动执行</li>\n</ol>\n<blockquote>\n<p>全量复制之前由 salve 主动发起而之后则是由 master 发起，每次为增量复制。</p>\n</blockquote>\n<h2 id=\"哨兵模式自动版反客为主\"><a class=\"anchor\" href=\"#哨兵模式自动版反客为主\">#</a> 哨兵模式 (自动版反客为主)</h2>\n<p>以上面的一主两从（主：6379，从：6380、6381）例子为基础</p>\n<ol>\n<li>\n<p>在自定义的 /myredis 目录下新建 sentinel.conf 文件</p>\n</li>\n<li>\n<p>配置哨兵，vim sentinel.conf</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>sentinemonitor mymaster <span class=\"token number\">127.0</span>.0.1 <span class=\"token number\">6379</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 其中 mymaster 为监控对象起的名称，1 表示从服务器变成主服务器至少需要有 1 个哨兵同意。</span></pre></td></tr></table></figure></li>\n<li>\n<p>启动哨兵: <code>redis-sentinel sentinel.conf</code></p>\n</li>\n<li>\n<p>加入哨兵后，当主服务器挂掉后，会在从机中选举出新的主服务器，而当原来主服务器恢复后，成为新主服务器的从服务器。</p>\n</li>\n<li>\n<p>新主机选举规则</p>\n<ul>\n<li>选择优先级靠前的：优先级在 redis.conf 中配置，默认 100；</li>\n<li>选择偏移量最大的：偏移量指过的原主机数据最全的，也就是最近同步的；</li>\n<li>选择 runid 最小的：每个 redis 实例启动后都会随机生成一个 40 位的 runid</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"redis集群\"><a class=\"anchor\" href=\"#redis集群\">#</a> Redis 集群</h2>\n<h3 id=\"什么是集群\"><a class=\"anchor\" href=\"#什么是集群\">#</a> 什么是集群</h3>\n<p>Redis 集群实现了对 Redis 的水平扩容，即启动 N 个 redis 节点，将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1/N。</p>\n<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>\n<h3 id=\"集群解决的问题\"><a class=\"anchor\" href=\"#集群解决的问题\">#</a> 集群解决的问题</h3>\n<p>容量不够，redis 如何进行扩容？</p>\n<p>并发写操作， redis 如何分摊？</p>\n<p>主从模式，薪火相传模式，主机宕机，导致 ip 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>\n<p>Redis3.0 中为此提供了解决方案 —— 无中心化集群配置，在此之前可以通过代理主机来解决。</p>\n<h3 id=\"如何构建集群\"><a class=\"anchor\" href=\"#如何构建集群\">#</a> 如何构建集群</h3>\n<p>在之前的配置中加入或修改一下集群相关配置，创建好对应数量的配置文件（本例中配置最简单的 6 个 redis 服务构成一个集群）</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cluster-enabled <span class=\"token function\">yes</span> <span class=\"token comment\"># 打开集群模式</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>cluster-config-file nodes-6379.conf <span class=\"token comment\"># 设定节点配置文件名</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>cluster-node-timeout <span class=\"token number\">15000</span> <span class=\"token comment\"># 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</span></pre></td></tr></table></figure><blockquote>\n<p>vim 可使用 % s/6379/6380 将所有 6379 替换为 6380</p>\n</blockquote>\n<p>启动服务，此时会在目录下生成 nodes-port.conf 文件（不是之前的配置文件，你要搞错了），通过 ll 命令查看是否生成。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>redis <span class=\"token parameter variable\">-server</span> redis6379.conf</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>redis <span class=\"token parameter variable\">-server</span> redis6380.conf</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>redis <span class=\"token parameter variable\">-server</span> redis6381.conf</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>redis <span class=\"token parameter variable\">-server</span> redis6389.conf</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>redis <span class=\"token parameter variable\">-server</span> redis6390.conf</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>redis <span class=\"token parameter variable\">-server</span> redis6391.conf</pre></td></tr></table></figure><p>合体成集群</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span>  /opt/redis-6.2.1/src</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>redis-cli <span class=\"token parameter variable\">--cluster</span> create --cluster-replicas <span class=\"token number\">1</span> <span class=\"token number\">192.168</span>.11.101:6379 <span class=\"token number\">192.168</span>.11.101:6380 <span class=\"token number\">192.168</span>.11.101:6381 <span class=\"token number\">192.168</span>.11.101:6389 <span class=\"token number\">192.168</span>.11.101:6390 <span class=\"token number\">192.168</span>.11.101:6391</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># --replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</span></pre></td></tr></table></figure><h4 id=\"登录\"><a class=\"anchor\" href=\"#登录\">#</a> 登录</h4>\n<p>普通方式登录： <code>redis-cli -p 6379</code> , 操作时会报错 MOVED...</p>\n<p>应该采用集群方式登录， <code>redis-cli  -c -p 6379</code> , -c 采用集群策略连接，设置数据会自动切换到相应的写主机，-p 后面端口可填集群中任意端口。登陆后可用 <code>cluster nodes</code>  查看集群信息。</p>\n<h4 id=\"redis-cluster-如何分配这六个节点\"><a class=\"anchor\" href=\"#redis-cluster-如何分配这六个节点\">#</a> redis cluster 如何分配这六个节点？</h4>\n<p>一个集群至少要有<strong>三个主节</strong>点，选项 --cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。分配原则<strong>尽量保证每个主数据库运行在不同的 IP 地址，每个从库和主库不在一个 IP 地址上。</strong></p>\n<h3 id=\"slots插槽\"><a class=\"anchor\" href=\"#slots插槽\">#</a> slots（插槽）</h3>\n<p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16 (key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16 (key) 语句用于计算键 key 的 CRC16 校验和 。集群中的每个节点负责处理一部分插槽。 比如， 如果一个集群有 3 个主节点， 其中：节点 A 负责处理 0 号至 5460 号插槽；节点 B 负责处理 5461 号至 10922 号插槽；节点 C 负责处理 10923 号至 16383 号插槽。CRC16 (k1) % 16384 = 5000，则 k1 会被放在节点 A 中。</p>\n<blockquote>\n<p>为什么插槽数量是 16384 ，而不是 Master 数量或者 2^16-1=65535 个（CRC16 能提供的值）？</p>\n<p>redis source code author antirez say ：</p>\n<p>1、正常的心跳包携带节点的完整配置，可以用幂等方式替换旧节点以更新旧配置。 这意味着它们包含原始形式的节点的插槽配置，它使用带有 16k 插槽的 2k 空间，但使用 65k 插槽时将使用高达 8k 的空间。<br />\n2、同时，由于其他设计权衡，Redis Cluster 不太可能扩展到超过 1000 个主节点。<br />\n因此，16k 处于正确的范围内，以确保每个主站有足够的插槽，最多 1000 个主站，但足够小的数字可以轻松地将插槽配置传播为原始位图。 请注意，在小型集群中，位图难以压缩，因为当 N 很小时，位图将设置插槽 / N 位，这是设置的大部分位。</p>\n</blockquote>\n<h3 id=\"在集群中录入值\"><a class=\"anchor\" href=\"#在集群中录入值\">#</a> 在集群中录入值</h3>\n<p>在 redis-cli 每次录入、查询键值，redis 都会计算出该 key 应该送往的插槽，如果不是该客户端对应服务器的插槽，redis 会报错，并告知应前往的 redis 实例地址和端口。</p>\n<p>redis-cli 客户端提供了 –c 参数实现自动重定向，如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p>\n<p>在集群中，不在一个 slot 下的键值，是不能使用 mget,mset 等多键操作。但是可以通过 {组名} 来定义组的概念，从而实现多键操作，redis 会使用组名来计算对应的 slot 值。如 <code>mset k1&#123;cust&#125; v1  k2&#123;cust&#125; v2 k3&#123;cust&#125; v3 k4&#123;cust&#125; v4</code></p>\n<h3 id=\"故障恢复\"><a class=\"anchor\" href=\"#故障恢复\">#</a> 故障恢复</h3>\n<p>如果主节点下线？从节点能否自动升为主节点？15 秒超时后，从节点升为主节点。</p>\n<p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>\n<p>如果所有某一段插槽的主从节点都宕掉，redis 服务是否还能继续？</p>\n<p>如果配置文件中 cluster-require-full-coverage 为 yes ，那么 ，整个集群都挂掉，如果为 no ，那么，只是该段插槽数据全都不能使用，也无法存储。</p>\n<h3 id=\"集群好处\"><a class=\"anchor\" href=\"#集群好处\">#</a> 集群好处</h3>\n<ul>\n<li>实现扩容</li>\n<li>分摊压力</li>\n<li>无中心化配置相对简单</li>\n</ul>\n<h3 id=\"集群不足\"><a class=\"anchor\" href=\"#集群不足\">#</a> 集群不足</h3>\n<ul>\n<li>不支持多键操作</li>\n<li>多键的 Redis 事务是不被支持的</li>\n<li>lua 脚本不被支持。</li>\n<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分 #的方案想要迁移至 redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li>\n</ul>\n<h2 id=\"redis应用问题及解决\"><a class=\"anchor\" href=\"#redis应用问题及解决\">#</a> Redis 应用问题及解决</h2>\n<h3 id=\"1-缓存穿透\"><a class=\"anchor\" href=\"#1-缓存穿透\">#</a> 1. 缓存穿透</h3>\n<h4 id=\"问题描述\"><a class=\"anchor\" href=\"#问题描述\">#</a> 问题描述</h4>\n<p>key 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库（频繁进行很多非正常的 url 访问）。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221015131449370.png\" alt=\"image-20221015131449370\" /></p>\n<h4 id=\"缓存穿透现象\"><a class=\"anchor\" href=\"#缓存穿透现象\">#</a> 缓存穿透现象</h4>\n<ul>\n<li>应用服务器压力变大</li>\n<li>redis 命中率降低</li>\n<li>一直查询数据库，使得数据库压力太大而压垮</li>\n</ul>\n<p>其实 redis 在这个过程中一直平稳运行，崩溃的是我们的数据库（如 MySQL）。</p>\n<h4 id=\"解决方案\"><a class=\"anchor\" href=\"#解决方案\">#</a> 解决方案</h4>\n<ol>\n<li><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</li>\n<li><strong>设置可访问的名单（白名单）</strong>：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。</li>\n<li><strong>采用布隆过滤器</strong>：布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量 (位图) 和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</li>\n<li><strong>进行实时监控</strong>：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</li>\n</ol>\n<h3 id=\"缓存击穿\"><a class=\"anchor\" href=\"#缓存击穿\">#</a> 缓存击穿</h3>\n<h4 id=\"问题描述-2\"><a class=\"anchor\" href=\"#问题描述-2\">#</a> 问题描述</h4>\n<p>key 对应的数据存在，但在 redis 中过期，此时若有<strong>大量并发请求</strong>过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221013172834245.png\" alt=\"image-20221013172834245\" /></p>\n<h4 id=\"缓存击穿现象\"><a class=\"anchor\" href=\"#缓存击穿现象\">#</a> 缓存击穿现象</h4>\n<ol>\n<li>数据库访问压力瞬时增加，数据库崩溃</li>\n<li>redis 里面没有出现大量 key 过期</li>\n<li>redis 正常运行</li>\n</ol>\n<h4 id=\"解决方案-2\"><a class=\"anchor\" href=\"#解决方案-2\">#</a> 解决方案</h4>\n<p>key 可能会在某些时间点被超高并发地访问，是一种非常 “热点” 的数据。这个时候，需要考虑缓存被 “击穿” 的问题，可以通过一下方案解决：</p>\n<ol>\n<li>\n<p>预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长</p>\n</li>\n<li>\n<p>实时调整：现场监控哪些数据热门，实时调整 key 的过期时长</p>\n</li>\n<li>\n<p>使用锁：</p>\n<ul>\n<li>在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。</li>\n<li>先使用某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key，<em>就是设置一个锁</em></li>\n<li>当操作返回成功时，再进行 load db 的操作，并回设缓存，最后删除 mutex key；</li>\n<li>当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法。</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221015132311885.png\" alt=\"使用锁流程\" /></p>\n<h3 id=\"缓存雪崩\"><a class=\"anchor\" href=\"#缓存雪崩\">#</a> 缓存雪崩</h3>\n<h4 id=\"问题描述-3\"><a class=\"anchor\" href=\"#问题描述-3\">#</a> 问题描述</h4>\n<p>key 对应的数据存在，但在 redis 中过期，此时若有<strong>大量并发请求</strong>过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p>\n<p>缓存雪崩与缓存击穿的<strong>区别在于这里针对很多 key 缓存，前者则是某一个 key</strong>。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221015132819943.png\" alt=\"image-20221015132819943\" /></p>\n<h4 id=\"解决方案-3\"><a class=\"anchor\" href=\"#解决方案-3\">#</a> 解决方案</h4>\n<ol>\n<li><strong>构建多级缓存架构</strong>：nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）</li>\n<li><strong>使用锁或队列</strong>：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li>\n<li><strong>设置过期标志更新缓存</strong>：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。</li>\n<li><strong>将缓存失效时间分散开</strong>：比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>\n</ol>\n<h3 id=\"分布式锁\"><a class=\"anchor\" href=\"#分布式锁\">#</a> 分布式锁</h3>\n<h4 id=\"问题描述-4\"><a class=\"anchor\" href=\"#问题描述-4\">#</a> 问题描述</h4>\n<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要一种跨 JVM 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>\n<h4 id=\"常用实现方案\"><a class=\"anchor\" href=\"#常用实现方案\">#</a> 常用实现方案</h4>\n<ol>\n<li>基于数据库实现分布式锁</li>\n<li>基于缓存（Redis 等）</li>\n<li>基于 Zookeeper</li>\n</ol>\n<p>其中通过 redis 实现性能最高，通过 zookeeper 实现可靠性最高。</p>\n<h4 id=\"redis实现通过setnx-实现\"><a class=\"anchor\" href=\"#redis实现通过setnx-实现\">#</a> Redis 实现（通过 setnx 实现）</h4>\n<p>只在键不存在时，才对键进行设置操作 (SET key value NX 效果等同于 SETNX key value)。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221015133725964.png\" alt=\"image-20221015133725964\" /></p>\n<p><strong>注意事项</strong>：</p>\n<ol>\n<li>设置锁的过期时间，防止发生死锁</li>\n<li>setnx 获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁，防止误删</li>\n<li>需要保证删除锁操作的原子性，可使用 LUA 脚本</li>\n</ol>\n<h2 id=\"redis6新特性\"><a class=\"anchor\" href=\"#redis6新特性\">#</a> Redis6 新特性</h2>\n<h3 id=\"acl\"><a class=\"anchor\" href=\"#acl\">#</a> ACL</h3>\n<p>Redis ACL 是 Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。在 Redis 5 版本之前，Redis 安全规则只有密码控制，还有通过 rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供 ACL 的功能对用户进行更细粒度的权限控制 ：</p>\n<p>（1）接入权限：用户名和密码</p>\n<p>（2）可以执行的命令</p>\n<p>（3）可以操作的 KEY</p>\n<h3 id=\"io多线程\"><a class=\"anchor\" href=\"#io多线程\">#</a> IO 多线程</h3>\n<p>Redis 6 加入多线程，但跟 Memcached 这种从 IO 处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/Li-Changwu/image/redis/image-20221015134757872.png\" alt=\"image-20221015134757872\" /></p>\n<p>另外，多线程 IO 默认也是不开启的，需要再配置文件中配置：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>io-threads-do-reads  <span class=\"token function\">yes</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>io-threads <span class=\"token number\">4</span></pre></td></tr></table></figure>",
            "tags": [
                "学习笔记",
                "redis",
                "nosql"
            ]
        }
    ]
}